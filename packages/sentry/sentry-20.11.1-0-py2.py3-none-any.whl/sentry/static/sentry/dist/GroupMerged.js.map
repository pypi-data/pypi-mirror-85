{"version":3,"sources":["webpack:///./app/actions/groupingActions.tsx","webpack:///./app/stores/groupingStore.tsx","webpack:///./app/components/flowLayout.tsx","webpack:///./app/components/spreadLayout.tsx","webpack:///./app/components/toolbar.tsx","webpack:///./app/views/organizationGroupDetails/groupMerged/mergedItem.jsx","webpack:///./app/views/organizationGroupDetails/groupMerged/mergedToolbar.jsx","webpack:///./app/views/organizationGroupDetails/groupMerged/mergedList.jsx","webpack:///./app/views/organizationGroupDetails/groupMerged/index.jsx"],"names":["GroupingActions","Reflux","createActions","storeConfig","listenables","api","Client","init","state","this","getInitialState","Object","entries","forEach","key","value","mergedItems","unmergeList","Map","unmergeState","unmergeDisabled","unmergeLastCollapsed","enableFingerprintCompare","similarItems","filteredSimilarItems","similarLinks","mergeState","mergeList","mergedLinks","mergeDisabled","loading","error","setStateForId","map","idOrIds","newState","Array","isArray","id","mergedState","has","get","set","isAllUnmergedSelected","lockedItems","from","values","filter","busy","size","latestEvent","length","convertScoreStructure","scoreMap","version","hasOwnProperty","newScoreMap","scoreMapKeys","keys","scoreMapKey","includes","onFetch","toFetchArray","requests","triggerFetchState","promises","endpoint","queryParams","dataKey","Promise","resolve","reject","request","method","data","success","_","jqXHR","links","getResponseHeader","err","responseJSON","detail","responseProcessors","merged","item","similar","issue","convertedScore","isBelowThreshold","scores","scoreKeys","find","score","checkBelowThreshold","scoresByInterface","scoreKey","reduce","acc","String","split","interfaceName","push","aggregate","avg","sum","all","then","resultsArray","items","onToggleMerge","checked","undefined","triggerMergeState","onToggleUnmerge","fingerprint","eventId","triggerUnmergeState","onUnmerge","groupId","loadingMessage","successMessage","errorMessage","ids","Error","addLoadingMessage","query","addSuccessMessage","clear","addErrorMessage","complete","onMerge","params","projectId","orgId","merge","itemIds","parent","trigger","mergedParent","onToggleCollapseFingerprints","collapsed","onToggleCollapseFingerprint","pick","createStore","FlowLayout","p","vertical","center","truncate","propTypes","PropTypes","bool","defaultProps","SpreadLayout","responsive","children","className","props","cx","classNames","Toolbar","theme","backgroundSecondary","border","MergedItem","createReactClass","displayName","mixins","listenTo","GroupingStore","onGroupingChange","stateForId","setState","handleToggleEvents","toggleCollapseFingerprint","handleLabelClick","e","preventDefault","handleToggle","disabled","event","toggleUnmerge","handleCheckClick","render","checkboxDisabled","MergedGroup","Controls","expanded","onClick","ActionColumn","onChange","Fingerprint","htmlFor","Collapse","direction","MergedEventList","EventDetails","hideIcons","hideLevel","innerBorder","space","text","familyMono","MergedToolbar","onGroupingUpdate","updateObj","handleShowDiff","project","baseEventId","targetEventId","openDiffModal","baseIssueId","targetIssueId","stopPropagation","onToggleCollapse","unmergeCount","StyledToolbar","title","t","message","onConfirm","CompareButton","Button","MergedList","renderEmpty","pageLinks","itemsWithLatestEvent","count","MergedItems","slug","React","Component","GroupMergedView","location","componentWillMount","fetchData","componentWillReceiveProps","nextProps","search","getEndpoint","type","limit","queryString","fetch","handleCollapse","collapseFingerprints","handleUnmerge","unmerge","isLoading","isError","isLoadedSuccessfully","onRetry","toggleCollapseFingerprints"],"mappings":"4FAAA,YAGMA,EAHN,OAGwBC,EAAOC,cAAc,CAC3C,QACA,sBACA,gBACA,cACA,UACA,QACA,4BACA,+BAEaF,O,stBCAf,IA2IMG,EAA2E,CAC/EC,YAAa,CAACJ,KACdK,IAAK,IAAIC,IAETC,KAJ+E,WAIxE,WACCC,EAAQC,KAAKC,kBAEnBC,OAAOC,QAAQJ,GAAOK,SAAQ,YAAkB,eAAhBC,EAAgB,KAAXC,EAAW,KAC9C,EAAKD,GAAOC,MAIhBL,gBAZ+E,WAa7E,MAAO,CAELM,YAAa,GAEbC,YAAa,IAAIC,IAEjBC,aAAc,IAAID,IAElBE,iBAAiB,EAEjBC,sBAAsB,EAEtBC,0BAA0B,EAC1BC,aAAc,GACdC,qBAAsB,GACtBC,aAAc,GACdC,WAAY,IAAIR,IAChBS,UAAW,GACXC,YAAa,GACbC,eAAe,EACfC,SAAS,EACTC,OAAO,IAIXC,cAtC+E,SAsCjEC,EAAKC,EAASC,GAG1B,OAFYC,MAAMC,QAAQH,GAAWA,EAAU,CAACA,IAErCD,KAAI,SAAAK,GACb,IACMC,EAAc,EAAH,KADFN,EAAIO,IAAIF,IAAOL,EAAIQ,IAAIH,IAAQ,IACZH,GAElC,OADAF,EAAIS,IAAIJ,EAAIC,GACLA,MAIXI,sBAjD+E,WAkD7E,IAAMC,EACHR,MAAMS,KAAKpC,KAAKU,aAAa2B,UAA6BC,QACzD,qBAAEC,SACC,GACP,OACEvC,KAAKQ,YAAYgC,OACjBxC,KAAKO,YAAY+B,QAAO,sBAAEG,eAAgCC,OACxDP,EAAYO,QAIlBC,sBA7D+E,SA6DzDC,EAAUC,GAK9B,GAJID,EAASE,eAAe,mDACnBF,EAAS,4CAGbC,GAAuB,MAAZA,EACd,OAAOD,EAGT,IAAMG,EAAc,GAEdC,EAAe9C,OAAO+C,KAAKL,GAEjC,IAAK,IAAMvC,KAAO2C,EAAc,CAC9B,IAAME,EAAcF,EAAa3C,GAC7B6C,EAAYC,SAAS,+BACvBJ,EAAY,sCAAwCH,EAASM,GAG3DA,EAAYC,SAAS,6BACvBJ,EAAY,wCAA0CH,EAASM,GAG7DA,EAAYC,SAAS,6BACvBJ,EAAY,8BAAgCH,EAASM,IAKzD,OAAOH,GAITK,QA9F+E,SA8FvEC,GAAc,aACdC,EAAWD,GAAgBrD,KAAKqD,aAChCR,EAAUQ,aAAH,YAAGA,EAAe,UAAlB,aAAG,EAAmBR,QAGnC7C,KAAKF,OACLE,KAAKuD,oBAEL,IAAMC,EAAWF,EAAS9B,KACxB,gBAAEiC,EAAF,EAAEA,SAAUC,EAAZ,EAAYA,YAAaC,EAAzB,EAAyBA,QAAzB,OACE,IAAIC,SAAQ,SAACC,EAASC,GACpB,EAAKlE,IAAImE,QAAQN,EAAU,CACzBO,OAAQ,MACRC,KAAMP,EACNQ,QAAS,SAACD,EAAME,EAAGC,GACjBP,EAAQ,CACNF,UACAM,OACAI,MAAOD,EAAQA,EAAME,kBAAkB,QAAU,QAGrDhD,MAAO,SAAAiD,GAAO,MACNjD,GAAQ,UAAAiD,EAAIC,oBAAJ,eAAkBC,UAAU,EAC1CX,EAAOxC,YAMXoD,EAAyC,CAC7CC,OAAQ,SAAAC,GAKN,OAHA,EAAKrD,cAAc,EAAKb,aAAckE,EAAK/C,GAAI,CAC7CU,KAAqB,WAAfqC,EAAK7E,QAEN6E,GAETC,QAAS,YAAuB,eAArBC,EAAqB,KAAdlC,EAAc,KACxBmC,EAAiB,EAAKpC,sBAAsBC,EAAUC,GAEtDmC,EA9Qc,WAAiB,IAAhBC,EAAgB,uDAAP,GAC9BC,EAAYhF,OAAO+C,KAAKgC,GAC9B,OAAQC,EAAU1D,KAAI,SAAAnB,GAAG,OAAI4E,EAAO5E,MAAM8E,MAAK,SAAAC,GAAK,OAAIA,GALxC,MAiReC,CAAoBN,GAGvCO,EAAoBpF,OAAO+C,KAAK8B,GACnCvD,KAAI,SAAA+D,GAAQ,MAAI,CAACA,EAAUR,EAAeQ,OAC1CC,QAAO,SAACC,EAAD,GAA4B,eAArBF,EAAqB,KAAXH,EAAW,OAEVM,OAAOH,GAAUI,MAAM,KAAxCC,EAF2B,YASlC,OALKH,EAAIG,KACPH,EAAIG,GAAiB,IAEvBH,EAAIG,GAAeC,KAAK,CAACN,EAAUH,IAE5BK,IACN,IAGCK,EAAY5F,OAAO+C,KAAKqC,GAC3B9D,KAAI,SAAAoE,GAAa,MAAI,CAACA,EAAeN,EAAkBM,OACvDJ,QAAO,SAACC,EAAD,GAAqC,eAA9BG,EAA8B,KAGrCX,EAHqC,KAGlB3C,QAAO,mBAAyB,OAAzB,eAE1ByD,EAAMd,EAAOO,QAAO,SAACQ,EAAD,UAAoBA,EAApB,cAAiC,GAAKf,EAAOvC,OAGvE,OADA+C,EAAIG,GAAiBG,EACdN,IACN,IAEL,MAAO,CACLX,QACAM,MAAOL,EACPO,oBACAQ,YACAd,sBASN,OAJI3B,IACFrD,KAAKqD,aAAeA,GAGfO,QAAQqC,IAAIzC,GAAU0C,MAC3B,SAAAC,GACGA,EAAgC/F,SAAQ,YAA4B,IAA1BuD,EAA0B,EAA1BA,QAASM,EAAiB,EAAjBA,KAAMI,EAAW,EAAXA,MAClD+B,EAECnC,EAAmCzC,IAAIkD,EAAmBf,IAEjE,EAAK,GAAD,OAAIA,EAAJ,UAAsByC,EAC1B,EAAK,GAAD,OAAIzC,EAAJ,UAAsBU,KAG5B,EAAKhD,SAAU,EACf,EAAKC,OAAQ,EACb,EAAKiC,uBAEP,WACE,EAAKlC,SAAU,EACf,EAAKC,OAAQ,EACb,EAAKiC,wBAMX8C,cA3M+E,SA2MjExE,GACZ,IAAIyE,GAAU,EAGRvG,EAAQC,KAAKiB,WAAWc,IAAIF,GAAM7B,KAAKiB,WAAWe,IAAIH,QAAM0E,GAE9C,KAAhBxG,aAAA,EAAAA,EAAOwC,QAIPvC,KAAKkB,UAAUiC,SAAStB,GAC1B7B,KAAKkB,UAAYlB,KAAKkB,UAAUoB,QAAO,SAAAsC,GAAI,OAAIA,IAAS/C,MAExD7B,KAAKkB,UAAL,cAAqBlB,KAAKkB,WAA1B,CAAqCW,IACrCyE,GAAU,GAGZtG,KAAKuB,cAAcvB,KAAKiB,WAAYY,EAAI,CACtCyE,YAGFtG,KAAKwG,sBAIPC,gBApO+E,YAoOvC,eAAvBC,EAAuB,KAAVC,EAAU,KAClCL,GAAU,EAGRvG,EAAQC,KAAKU,aAAasB,IAAI0E,IAEhB,KAAhB3G,aAAA,EAAAA,EAAOwC,QAIPvC,KAAKQ,YAAYuB,IAAI2E,GACvB1G,KAAKQ,YAAL,OAAwBkG,IAExB1G,KAAKQ,YAAYyB,IAAIyE,EAAaC,GAClCL,GAAU,GAIZtG,KAAKuB,cAAcvB,KAAKU,aAAcgG,EAAa,CACjDJ,YAIFtG,KAAKW,gBAA4C,IAA1BX,KAAKQ,YAAYgC,MAAcxC,KAAKkC,wBAC3DlC,KAAKa,yBAAqD,IAA1Bb,KAAKQ,YAAYgC,KAEjDxC,KAAK4G,wBAGPC,UAjQ+E,YAiQZ,WAAxDC,EAAwD,EAAxDA,QAASC,EAA+C,EAA/CA,eAAgBC,EAA+B,EAA/BA,eAAgBC,EAAe,EAAfA,aAC5CC,EAAMvF,MAAMS,KAAKpC,KAAKQ,YAAYyC,QAExC,OAAO,IAAIW,SAAQ,SAACC,EAASC,GACvB,EAAK5B,wBACP4B,EAAO,IAAIqD,MAAM,uCAKnB,EAAKxG,iBAAkB,EAGvB,EAAKY,cAAc,EAAKb,aAAcwG,EAAK,CACzCZ,SAAS,EACT/D,MAAM,IAER,EAAKqE,sBACLQ,YAAkBL,GAElB,EAAKnH,IAAImE,QAAT,kBAA4B+C,EAA5B,YAA+C,CAC7C9C,OAAQ,SACRqD,MAAO,CACLxF,GAAIqF,GAENhD,QAAS,WACPoD,YAAkBN,GAGlB,EAAKzF,cAAc,EAAKb,aAAcwG,EAAK,CACzCZ,SAAS,EACT/D,MAAM,IAER,EAAK/B,YAAY+G,SAEnBjG,MAAO,WACLkG,YAAgBP,GAChB,EAAK1F,cAAc,EAAKb,aAAcwG,EAAK,CACzCZ,SAAS,EACT/D,MAAM,KAGVkF,SAAU,WACR,EAAK9G,iBAAkB,EACvBkD,EAAQ,EAAK+C,+BAOrBc,QApT+E,YAoT3C,WAA3BC,EAA2B,EAA3BA,OAAQN,EAAmB,EAAnBA,MAAOO,EAAY,EAAZA,UACtB,GAAKD,EAAL,CAIA,IAAMT,EAAMlH,KAAKkB,UAkDjB,OAhDAlB,KAAKoB,eAAgB,EAErBpB,KAAKuB,cAAcvB,KAAKiB,WAAYiG,EAAsB,CACxD3E,MAAM,IAGRvC,KAAKwG,oBAEW,IAAI5C,SAAQ,SAAAC,GAAW,IAE9BgE,EAAkBF,EAAlBE,MAAOf,EAAWa,EAAXb,QAEd,EAAKlH,IAAIkI,MACP,CACED,QACAD,UAAWA,GAAaD,EAAOC,UAC/BG,QAAS,GAAF,WAAMb,GAAN,CAAWJ,IAClBO,SAEF,CACEnD,QAAS,SAAAD,GAAQ,OACXA,aAAJ,YAAIA,EAAM6D,aAAV,aAAI,EAAaE,SACf,EAAKC,QAAQ,CACXC,aAAcjE,EAAK6D,MAAME,SAK7B,EAAKzG,cAAc,EAAKN,WAAYiG,EAAsB,CACxDZ,SAAS,EACT/D,MAAM,IAER,EAAKrB,UAAY,IAEnBI,MAAO,WACL,EAAKC,cAAc,EAAKN,WAAYiG,EAAsB,CACxDZ,SAAS,EACT/D,MAAM,KAGVkF,SAAU,WACR,EAAKrG,eAAgB,EACrByC,EAAQ,EAAK2C,6BAUvB2B,6BA/W+E,WAgX7EnI,KAAKuB,cACHvB,KAAKU,aACLV,KAAKO,YAAYiB,KAAI,qBAAEK,MACvB,CACEuG,WAAYpI,KAAKY,uBAIrBZ,KAAKY,sBAAwBZ,KAAKY,qBAElCZ,KAAKiI,QAAQ,CACXrH,qBAAsBZ,KAAKY,qBAC3BF,aAAcV,KAAKU,gBAIvB2H,4BAhY+E,SAgYnD3B,GAC1B,IAAM0B,EACJpI,KAAKU,aAAaqB,IAAI2E,IAAgB1G,KAAKU,aAAasB,IAAI0E,GAAa0B,UAC3EpI,KAAKuB,cAAcvB,KAAKU,aAAcgG,EAAa,CAAC0B,WAAYA,IAChEpI,KAAKiI,QAAQ,CACXvH,aAAcV,KAAKU,gBAIvB6C,kBAzY+E,WA0Y7E,IAAMxD,EAAQ,EAAH,CACTe,aAAcd,KAAKc,aAAawB,QAAO,qBAAE0C,oBACzCjE,qBAAsBf,KAAKc,aAAawB,QACtC,qBAAE0C,qBAEDsD,IAAKtI,KAAM,CACZ,cACA,cACA,eACA,aACA,eACA,UACA,WAIJ,OADAA,KAAKiI,QAAQlI,GACNA,GAGT6G,oBA7Z+E,WA8Z7E,IAAM7G,EAAQuI,IAAKtI,KAAM,CACvB,kBACA,eACA,cACA,2BACA,yBAGF,OADAA,KAAKiI,QAAQlI,GACNA,GAGTyG,kBAza+E,WA0a7E,IAAMzG,EAAQuI,IAAKtI,KAAM,CAAC,gBAAiB,aAAc,cAEzD,OADAA,KAAKiI,QAAQlI,GACNA,IAIIP,QAAO+I,YAAY7I,I,6DCtjB5B8I,EAAa,YAAO,MAAP,yCAAH,0DAII,SAAAC,GAAC,OAAKA,EAAEC,SAAW,SAAW,OAJlC,qBAKK,SAAAD,GAAC,OAAKA,EAAEE,OAAS,SAAW,OALjC,cAMF,SAAAF,GAAC,OAAKA,EAAEG,SAAW,SAAW,OAN5B,KAShBJ,EAAWK,UAAY,CACrBF,OAAQG,IAAUC,KAClBL,SAAUI,IAAUC,KACpBH,SAAUE,IAAUC,MAGtBP,EAAWQ,aAAe,CACxBJ,UAAU,GAGGJ,O,sGCxBTS,EAAe,SAAC,GAMT,QALXC,kBAKW,aAJXP,cAIW,SAHXQ,EAGW,EAHXA,SACAC,EAEW,EAFXA,UACGC,EACQ,sDACLC,EAAKC,IAAW,gBAAiBH,EAAW,CAChDT,SACA,mBAAoBO,IAGtB,OACE,yBAASG,EAAT,CAAgBD,UAAWE,IACxBH,IAdDF,E,2BA0BSA,O,6CCrCTO,EAAU,YAAO,MAAP,sCAAH,eACG,SAAAf,GAAC,OAAIA,EAAEgB,MAAMC,sBADhB,sBAES,SAAAjB,GAAC,OAAIA,EAAEgB,MAAME,SAFtB,qEAKW,SAAAlB,GAAC,OAAIA,EAAEgB,MAAME,SALxB,cASEH,O,4YCGTI,EAAaC,IAAiB,CAClCC,YAAa,aAcbC,OAAQ,CAACvK,IAAOwK,SAASC,IAAe,qBAExChK,gBAjBkC,WAkBhC,MAAO,CACLmI,WAAW,EACX9B,SAAS,EACT/D,MAAM,IAIV2H,iBAzBkC,YAyBD,WAAfxJ,EAAe,EAAfA,aAChB,GAAKA,EAAL,CAD+B,IAKxBgG,EAAe1G,KAAKqJ,MAApB3C,YACDyD,EAAazJ,EAAaqB,IAAI2E,IAAgBhG,EAAasB,IAAI0E,GAChEyD,GAILjK,OAAO+C,KAAKkH,GAAY/J,SAAQ,SAAAC,GAC1B8J,EAAW9J,KAAS,EAAKN,MAAMM,IAInC,EAAK+J,SAAL,OACG/J,EAAM8J,EAAW9J,UAKxBgK,mBA/CkC,WA+Cb,IACZ3D,EAAe1G,KAAKqJ,MAApB3C,YACPnH,IAAgB+K,0BAA0B5D,IAI5C6D,iBArDkC,SAqDjBC,GACfA,EAAEC,kBAGJC,aAzDkC,WAyDnB,MAC0B1K,KAAKqJ,MAArCsB,EADM,EACNA,SAAUjE,EADJ,EACIA,YAAakE,EADjB,EACiBA,MAE1BD,GAAY3K,KAAKD,MAAMwC,MAK3BhD,IAAgBsL,cAAc,CAACnE,EAAakE,EAAM/I,MAGpDiJ,iBApEkC,aAyElCC,OAzEkC,WAyEzB,MACgC/K,KAAKqJ,MAArCsB,EADA,EACAA,SAAUC,EADV,EACUA,MAAOlE,EADjB,EACiBA,YAClBsE,EAAmBL,GAAY3K,KAAKD,MAAM4K,SAGhD,OACE,YAACM,EAAD,CAAa1I,KAAMvC,KAAKD,MAAMwC,MAC5B,YAAC2I,EAAD,CAAUC,UAAWnL,KAAKD,MAAMqI,WAC9B,YAAC,IAAD,CAAYgD,QAASpL,KAAK0K,cACxB,YAACW,EAAD,KACE,YAAC,IAAD,CACExJ,GAAI6E,EACJpG,MAAOoG,EACPJ,QAAStG,KAAKD,MAAMuG,QACpBqE,SAAUK,EACVM,SAAUtL,KAAK8K,oBAInB,YAACS,EAAD,CAAaH,QAASpL,KAAKuK,iBAAkBiB,QAAS9E,GACnDA,IAIL,uBACE,yBACA,YAAC+E,EAAD,CAAUL,QAASpL,KAAKqK,oBACrBrK,KAAKD,MAAMqI,UACV,YAAC,IAAD,CAAasD,UAAU,OAAOlJ,KAAK,OAEnC,YAAC,IAAD,CAAakJ,UAAU,KAAKlJ,KAAK,WAMvCxC,KAAKD,MAAMqI,WACX,YAACuD,EAAD,CAAiBvC,UAAU,cACxBwB,GACC,YAACgB,EAAD,CAAcxC,UAAU,iBACtB,YAAC,IAAD,KACE,YAAC,IAAD,CAAoBnF,KAAM2G,EAAOiB,WAAS,EAACC,WAAS,WAWhEb,EAAc,YAAO,MAAP,0CAChB,SAAAxC,GAAC,OAAIA,EAAElG,MAAQ,iBADF,KAIX8I,EAAe,YAAO,MAAP,0CAAH,2FAUZH,EAAW,YAAO,MAAP,sCAAH,oEAGY,SAAAzC,GAAC,OAAIA,EAAEgB,MAAMsC,cAHzB,qCAKDC,YAAM,IALL,OAMV,SAAAvD,GAAC,OAAIA,EAAE0C,UAAF,mCAA0C1C,EAAEgB,MAAMsC,eAN7C,IAQVd,EARU,6FAcmB,SAAAxC,GAAC,OAAIA,EAAEgB,MAAMsC,cAdhC,OAmBRR,EAAc,YAAO,QAAP,yCAAH,gBACA,SAAA9C,GAAC,OAAIA,EAAEgB,MAAMwC,KAAKC,aADlB,IAGKhB,EAHL,oCASXO,EAAW,YAAO,OAAP,sCAAH,0DAKRE,EAAkB,YAAO,MAAP,6CAAH,wDAKfC,EAAe,YAAO,MAAP,0CAAH,kGASHhC,I,oFCvLTuC,GAAgBtC,IAAiB,CACrCC,YAAa,gBAUbC,OAAQ,CAACvK,IAAOwK,SAASC,IAAe,qBAExChK,gBAbqC,WAanB,IAEdO,EAIEyJ,IAJFzJ,YACAI,EAGEqJ,IAHFrJ,qBACAD,EAEEsJ,IAFFtJ,gBAIF,MAAO,CACLE,yBAHEoJ,IADFpJ,yBAKAL,cACAI,uBACAD,oBAIJyL,iBA7BqC,SA6BpBC,GAQfrM,KAAKoK,SAAS9B,IAAK+D,EAPC,CAClB,uBACA,kBACA,cACA,+BAMJC,eAxCqC,SAwCtB9B,GAAG,MACkBxK,KAAKqJ,MAAhCvC,EADS,EACTA,QAASyF,EADA,EACAA,QAAS1E,EADT,EACSA,MACnB1H,EAAUH,KAAKD,MAAMS,YAAYL,UAGvC,GAAoC,IAAhCH,KAAKD,MAAMS,YAAYgC,KAA3B,CALgB,MAUqBb,MAAMS,KAAKjC,GAASqB,KACvD,kCAXc,WAUTgL,EAVS,KAUIC,EAVJ,KAchBC,YAAc,CACZC,YAAa7F,EACb8F,cAAe9F,EACf0F,cACAC,gBACA5E,QACA0E,YAGF/B,EAAEqC,oBAGJ9B,OAlEqC,WAkE5B,MAC+B/K,KAAKqJ,MAApCxC,EADA,EACAA,UAAWiG,EADX,EACWA,iBACZC,EAAgB/M,KAAKD,MAAMS,aAAeR,KAAKD,MAAMS,YAAYgC,MAAS,EAEhF,OACE,YAACwK,GAAD,KACE,YAAC,KAAD,KACE,YAAC,KAAD,KACE,uBACE,YAAC,KAAD,CACErC,SAAU3K,KAAKD,MAAMY,gBACrBsM,MAAOC,YAAE,aAAD,OAAcH,EAAd,YACRI,QAASD,YACP,8GAEF9D,UAAU,yBACVgE,UAAWvG,GAEVqG,YAAE,WATL,KASmBH,GAAgB,EATnC,KAYA,YAACM,GAAD,CACE7K,KAAK,QACLmI,UAAW3K,KAAKD,MAAMc,yBACtBuK,QAASpL,KAAKsM,gBAEbY,YAAE,cAIT,YAAC,KAAD,KACE,uBACE,YAAC,IAAD,CAAQ1K,KAAK,QAAQ4I,QAAS0B,GAC3B9M,KAAKD,MAAMa,qBAAuBsM,YAAE,cAAgBA,YAAE,wBAUjEG,GAAgB,YAAOC,IAAP,4CAAH,eACFtB,YAAM,GADJ,KAIbgB,GAAgB,YAAOxD,KAAP,4CAAH,WACNwC,YAAM,IADA,IACQA,YAAM,GADd,KAIJG,M,6aCxHToB,G,mLAUJC,YAAc,kBACZ,YAAC,IAAD,KACE,qBAAIN,YAAE,wD,+CAID,MACiElN,KAAKqJ,MAAtEjD,EADA,EACAA,MAAOqH,EADP,EACOA,UAAWX,EADlB,EACkBA,iBAAkBjG,EADpC,EACoCA,UAAWgB,EAD/C,EAC+CA,MAAO0E,EADtD,EACsDA,QACvDmB,EAAuBtH,EAAM9D,QAAO,sBAAEG,eAG5C,OAFmBiL,EAAqBhL,OAAS,EAO/C,uBACE,sBACE,wBAAOwK,YAAE,0CACT,YAAC,IAAD,CAAYS,MAAOD,EAAqBhL,UAG1C,YAAC,GAAD,CACEoK,iBAAkBA,EAClBjG,UAAWA,EACXgB,MAAOA,EACP0E,QAASA,IAGX,YAACqB,GAAD,KACGF,EAAqBlM,KAAI,gBAAEK,EAAF,EAAEA,GAAIY,EAAN,EAAMA,YAAN,OACxB,YAAC,EAAD,CACEpC,IAAKwB,EACLgG,MAAOA,EACPD,UAAW2E,EAAQsB,KACnBlD,SAA2B,IAAjBvE,EAAM1D,OAChBkI,MAAOnI,EACPiE,YAAa7E,QAKnB,YAAC,IAAD,CAAY4L,UAAWA,KA9BlB,YAAC,IAAD,KAAQzN,KAAKwN,mB,GAtBDM,IAAMC,WAAzBR,G,yBA0DSA,UAETK,GAAc,YAAO,MAAP,0CAAH,qBACK,SAAAnF,GAAC,OAAIA,EAAEgB,MAAME,SADlB,qB,qkBC3DjB,IAAMqE,GAAkBnE,IAAiB,CACvCC,YAAa,kBAIbC,OAAQ,CAACvK,IAAOwK,SAASC,IAAe,qBAExChK,gBAPuC,WASrC,MAAO,CACLM,YAAa,GACbc,SAAS,EACTC,OAAO,EACP+F,MALkBrH,KAAKqJ,MAAM4E,SAAS5G,MAKnBA,OAAS,KAIhC6G,mBAjBuC,WAkBrClO,KAAKmO,aAGPC,0BArBuC,SAqBbC,GACxB,GACEA,EAAU1G,OAAOb,UAAY9G,KAAKqJ,MAAM1B,OAAOb,SAC/CuH,EAAUJ,SAASK,SAAWtO,KAAKqJ,MAAM4E,SAASK,OAClD,CACA,IAAM5K,EAAc2K,EAAUJ,SAAS5G,MACvCrH,KAAKoK,SACH,CACE/C,MAAO3D,EAAY2D,OAErBrH,KAAKmO,aAKX/B,iBApCuC,YAoCsB,IAA3C7L,EAA2C,EAA3CA,YAAaY,EAA8B,EAA9BA,YAAaE,EAAiB,EAAjBA,QAASC,EAAQ,EAARA,MAC/Cf,GACFP,KAAKoK,SAAS,CACZ7J,cACAY,cACAE,aAA4B,IAAZA,GAA0BA,EAC1CC,WAAwB,IAAVA,GAAwBA,KAK5CiN,YA/CuC,WA+CV,IAAjBC,EAAiB,uDAAV,SACX7G,EAAS3H,KAAKqJ,MAAM1B,OACpBjE,EAAc,GAAH,MACZ1D,KAAKqJ,MAAM4E,SAAS5G,OADR,IAEfoH,MAAO,GACPpH,MAAOrH,KAAKD,MAAMsH,QAGpB,wBAAkBM,EAAOb,QAAzB,YAAoC0H,EAApC,aAA6CE,YAAsBhL,KAGrEyK,UA1DuC,WA2DrC5O,IAAgBoP,MAAM,CACpB,CACElL,SAAUzD,KAAKuO,YAAY,UAC3B5K,QAAS,SACTD,YAAa1D,KAAKqJ,MAAM4E,SAAS5G,UAKvCuH,eApEuC,WAqErCrP,IAAgBsP,wBAGlBC,cAxEuC,WAyErCvP,IAAgBwP,QAAQ,CACtBjI,QAAS9G,KAAKqJ,MAAM1B,OAAOb,QAC3BC,eAAgB,GAAF,OAAKmG,YAAE,oBAAP,OACdlG,eAAgBkG,YAAE,6CAClBjG,aAAciG,YAAE,4CAIpBnC,OAjFuC,WAkFrC,IAAMiE,EAAYhP,KAAKD,MAAMsB,QACvB4N,EAAUjP,KAAKD,MAAMuB,QAAU0N,EAC/BE,GAAwBD,IAAYD,EAE1C,OACE,uBACE,YAAC,IAAD,CAAOR,KAAK,WACTtB,YACC,sGAIH8B,GAAa,YAAC,UAAD,MACbC,GACC,YAAC,IAAD,CACE9B,QAAQ,uDACRgC,QAASnP,KAAKmO,YAIjBe,GACC,YAAC,GAAD,CACErH,MAAO7H,KAAKqJ,MAAM1B,OAAOE,MACzB0E,QAASvM,KAAKqJ,MAAMkD,QACpBnG,MAAOpG,KAAKD,MAAMQ,YAClBkN,UAAWzN,KAAKD,MAAMoB,YACtB0F,UAAW7G,KAAK8O,cAChBhC,iBAAkBvN,IAAgB6P,iCAU/BpB","file":"GroupMerged.js","sourcesContent":["import Reflux from 'reflux';\n\n// Actions for \"Grouping\" view - for merging/unmerging events/issues\nconst GroupingActions = Reflux.createActions([\n  'fetch',\n  'showAllSimilarItems',\n  'toggleUnmerge',\n  'toggleMerge',\n  'unmerge',\n  'merge',\n  'toggleCollapseFingerprint',\n  'toggleCollapseFingerprints',\n]);\nexport default GroupingActions;\n","import Reflux from 'reflux';\nimport pick from 'lodash/pick';\n\nimport {Group, Project, Organization, Event} from 'app/types';\nimport {Client} from 'app/api';\nimport {\n  addErrorMessage,\n  addLoadingMessage,\n  addSuccessMessage,\n} from 'app/actionCreators/indicator';\nimport GroupingActions from 'app/actions/groupingActions';\n\n// Between 0-100\nconst MIN_SCORE = 0.6;\n\n// @param score: {[key: string]: number}\nconst checkBelowThreshold = (scores = {}) => {\n  const scoreKeys = Object.keys(scores);\n  return !scoreKeys.map(key => scores[key]).find(score => score >= MIN_SCORE);\n};\n\ntype State = {\n  // List of fingerprints that belong to issue\n  mergedItems: [];\n  // Map of {[fingerprint]: Array<fingerprint, event id>} that is selected to be unmerged\n  unmergeList: Map<any, any>;\n  // Map of state for each fingerprint (i.e. \"collapsed\")\n  unmergeState: Map<any, any>;\n  // Disabled state of \"Unmerge\" button in \"Merged\" tab (for Issues)\n  unmergeDisabled: boolean;\n  // If \"Collapse All\" was just used, this will be true\n  unmergeLastCollapsed: boolean;\n  // \"Compare\" button state\n  enableFingerprintCompare: boolean;\n  similarItems: [];\n  filteredSimilarItems: [];\n  similarLinks: string;\n  mergeState: Map<any, any>;\n  mergeList: Array<string>;\n  mergedLinks: string;\n  mergeDisabled: boolean;\n  loading: boolean;\n  error: boolean;\n};\n\ntype ScoreMap = Record<string, number | null>;\n\ntype Item = {\n  id: string;\n  latestEvent: Event;\n  state?: string;\n};\n\ntype ResponseProcessors = {\n  merged: (item: Item) => Item;\n  similar: (\n    data: [Group, ScoreMap]\n  ) => {\n    issue: Group;\n    score: ScoreMap;\n    scoresByInterface: Record<string, Array<[string, number | null]>>;\n    aggregate: Record<string, number>;\n    isBelowThreshold: boolean;\n  };\n};\n\ntype DataKey = keyof ResponseProcessors;\n\ntype Version = '1' | '2';\n\ntype ResultsAsArrayDataMerged = Array<Parameters<ResponseProcessors['merged']>[0]>;\n\ntype ResultsAsArrayDataSimilar = Array<Parameters<ResponseProcessors['similar']>[0]>;\n\ntype ResultsAsArray = Array<{\n  dataKey: DataKey;\n  data: ResultsAsArrayDataMerged | ResultsAsArrayDataSimilar;\n  links: string | null;\n}>;\n\ntype IdState = {\n  busy?: boolean;\n  checked?: boolean;\n  collapsed?: boolean;\n};\n\ntype GroupingStoreInterface = Reflux.StoreDefinition & {\n  init: () => void;\n  getInitialState: () => State;\n  setStateForId: (\n    map: Map<string, IdState>,\n    idOrIds: Array<string> | string,\n    newState: IdState\n  ) => Array<IdState>;\n  isAllUnmergedSelected: () => boolean;\n  convertScoreStructure: (scoreMap: ScoreMap, version?: Version) => ScoreMap;\n  onFetch: (\n    toFetchArray?: Array<{\n      dataKey: DataKey;\n      endpoint: string;\n      version?: Version;\n      queryParams?: Record<string, any>;\n    }>\n  ) => Promise<any>;\n  onToggleMerge: (id: string) => void;\n  onToggleUnmerge: (props: [string, string] | string) => void;\n  onUnmerge: (props: {\n    groupId: Group['id'];\n    loadingMessage?: string;\n    successMessage?: string;\n    errorMessage?: string;\n  }) => void;\n  onMerge: (props: {\n    params?: {\n      orgId: Organization['id'];\n      projectId: Project['id'];\n      groupId: Group['id'];\n    };\n    projectId?: Project['id'];\n    query?: string;\n  }) => undefined | Promise<any>;\n  onToggleCollapseFingerprints: () => void;\n  onToggleCollapseFingerprint: (fingerprint: string) => void;\n  triggerFetchState: () => Pick<\n    State,\n    | 'similarItems'\n    | 'filteredSimilarItems'\n    | 'mergedItems'\n    | 'mergedLinks'\n    | 'similarLinks'\n    | 'mergeState'\n    | 'unmergeState'\n    | 'loading'\n    | 'error'\n  >;\n  triggerUnmergeState: () => Pick<\n    State,\n    | 'unmergeDisabled'\n    | 'unmergeState'\n    | 'unmergeList'\n    | 'enableFingerprintCompare'\n    | 'unmergeLastCollapsed'\n  >;\n  triggerMergeState: () => Pick<State, 'mergeState' | 'mergeDisabled' | 'mergeList'>;\n};\n\ntype Internals = {\n  api: Client;\n};\n\ntype GroupingStore = Reflux.Store & GroupingStoreInterface;\n\nconst storeConfig: Reflux.StoreDefinition & Internals & GroupingStoreInterface = {\n  listenables: [GroupingActions],\n  api: new Client(),\n\n  init() {\n    const state = this.getInitialState();\n\n    Object.entries(state).forEach(([key, value]) => {\n      this[key] = value;\n    });\n  },\n\n  getInitialState() {\n    return {\n      // List of fingerprints that belong to issue\n      mergedItems: [],\n      // Map of {[fingerprint]: Array<fingerprint, event id>} that is selected to be unmerged\n      unmergeList: new Map(),\n      // Map of state for each fingerprint (i.e. \"collapsed\")\n      unmergeState: new Map(),\n      // Disabled state of \"Unmerge\" button in \"Merged\" tab (for Issues)\n      unmergeDisabled: true,\n      // If \"Collapse All\" was just used, this will be true\n      unmergeLastCollapsed: false,\n      // \"Compare\" button state\n      enableFingerprintCompare: false,\n      similarItems: [],\n      filteredSimilarItems: [],\n      similarLinks: '',\n      mergeState: new Map(),\n      mergeList: [],\n      mergedLinks: '',\n      mergeDisabled: false,\n      loading: true,\n      error: false,\n    };\n  },\n\n  setStateForId(map, idOrIds, newState) {\n    const ids = Array.isArray(idOrIds) ? idOrIds : [idOrIds];\n\n    return ids.map(id => {\n      const state = (map.has(id) && map.get(id)) || {};\n      const mergedState = {...state, ...newState};\n      map.set(id, mergedState);\n      return mergedState;\n    });\n  },\n\n  isAllUnmergedSelected() {\n    const lockedItems =\n      (Array.from(this.unmergeState.values()) as Array<IdState>).filter(\n        ({busy}) => busy\n      ) || [];\n    return (\n      this.unmergeList.size ===\n      this.mergedItems.filter(({latestEvent}) => !!latestEvent).length -\n        lockedItems.length\n    );\n  },\n\n  convertScoreStructure(scoreMap, version) {\n    if (scoreMap.hasOwnProperty('exception:stacktrace:application-chunks')) {\n      delete scoreMap['exception:stacktrace:application-chunks'];\n    }\n\n    if (!version || version === '1') {\n      return scoreMap;\n    }\n\n    const newScoreMap = {};\n\n    const scoreMapKeys = Object.keys(scoreMap);\n\n    for (const key in scoreMapKeys) {\n      const scoreMapKey = scoreMapKeys[key];\n      if (scoreMapKey.includes('message:character-5-shingle')) {\n        newScoreMap['message:message:character-shingles'] = scoreMap[scoreMapKey];\n        continue;\n      }\n      if (scoreMapKey.includes('value:character-5-shingle')) {\n        newScoreMap['exception:message:character-shingles'] = scoreMap[scoreMapKey];\n        continue;\n      }\n      if (scoreMapKey.includes('stacktrace:frames-pairs')) {\n        newScoreMap['exception:stacktrace:pairs'] = scoreMap[scoreMapKey];\n        continue;\n      }\n    }\n\n    return newScoreMap;\n  },\n\n  // Fetches data\n  onFetch(toFetchArray) {\n    const requests = toFetchArray || this.toFetchArray;\n    const version = toFetchArray?.[0]?.version;\n\n    // Reset state and trigger update\n    this.init();\n    this.triggerFetchState();\n\n    const promises = requests.map(\n      ({endpoint, queryParams, dataKey}) =>\n        new Promise((resolve, reject) => {\n          this.api.request(endpoint, {\n            method: 'GET',\n            data: queryParams,\n            success: (data, _, jqXHR) => {\n              resolve({\n                dataKey,\n                data,\n                links: jqXHR ? jqXHR.getResponseHeader('Link') : null,\n              });\n            },\n            error: err => {\n              const error = err.responseJSON?.detail || true;\n              reject(error);\n            },\n          });\n        })\n    );\n\n    const responseProcessors: ResponseProcessors = {\n      merged: item => {\n        // Check for locked items\n        this.setStateForId(this.unmergeState, item.id, {\n          busy: item.state === 'locked',\n        });\n        return item;\n      },\n      similar: ([issue, scoreMap]) => {\n        const convertedScore = this.convertScoreStructure(scoreMap, version);\n        // Hide items with a low scores\n        const isBelowThreshold = checkBelowThreshold(convertedScore);\n\n        // List of scores indexed by interface (i.e., exception and message)\n        const scoresByInterface = Object.keys(convertedScore)\n          .map(scoreKey => [scoreKey, convertedScore[scoreKey]])\n          .reduce((acc, [scoreKey, score]) => {\n            // tokenize scorekey, first token is the interface name\n            const [interfaceName] = String(scoreKey).split(':');\n\n            if (!acc[interfaceName]) {\n              acc[interfaceName] = [];\n            }\n            acc[interfaceName].push([scoreKey, score]);\n\n            return acc;\n          }, {});\n\n        // Aggregate score by interface\n        const aggregate = Object.keys(scoresByInterface)\n          .map(interfaceName => [interfaceName, scoresByInterface[interfaceName]])\n          .reduce((acc, [interfaceName, allScores]) => {\n            // `null` scores means feature was not present in both issues, do not\n            // include in aggregate\n            const scores = allScores.filter(([, score]) => score !== null);\n\n            const avg = scores.reduce((sum, [, score]) => sum + score, 0) / scores.length;\n\n            acc[interfaceName] = avg;\n            return acc;\n          }, {});\n\n        return {\n          issue,\n          score: convertedScore,\n          scoresByInterface,\n          aggregate,\n          isBelowThreshold,\n        };\n      },\n    };\n\n    if (toFetchArray) {\n      this.toFetchArray = toFetchArray;\n    }\n\n    return Promise.all(promises).then(\n      resultsArray => {\n        (resultsArray as ResultsAsArray).forEach(({dataKey, data, links}) => {\n          const items =\n            dataKey === 'similar'\n              ? (data as ResultsAsArrayDataSimilar).map(responseProcessors[dataKey])\n              : (data as ResultsAsArrayDataMerged).map(responseProcessors[dataKey]);\n          this[`${dataKey}Items`] = items;\n          this[`${dataKey}Links`] = links;\n        });\n\n        this.loading = false;\n        this.error = false;\n        this.triggerFetchState();\n      },\n      () => {\n        this.loading = false;\n        this.error = true;\n        this.triggerFetchState();\n      }\n    );\n  },\n\n  // Toggle merge checkbox\n  onToggleMerge(id) {\n    let checked = false;\n\n    // Don't do anything if item is busy\n    const state = this.mergeState.has(id) ? this.mergeState.get(id) : undefined;\n\n    if (state?.busy === true) {\n      return;\n    }\n\n    if (this.mergeList.includes(id)) {\n      this.mergeList = this.mergeList.filter(item => item !== id);\n    } else {\n      this.mergeList = [...this.mergeList, id];\n      checked = true;\n    }\n\n    this.setStateForId(this.mergeState, id, {\n      checked,\n    });\n\n    this.triggerMergeState();\n  },\n\n  // Toggle unmerge check box\n  onToggleUnmerge([fingerprint, eventId]) {\n    let checked = false;\n\n    // Uncheck an item to unmerge\n    const state = this.unmergeState.get(fingerprint);\n\n    if (state?.busy === true) {\n      return;\n    }\n\n    if (this.unmergeList.has(fingerprint)) {\n      this.unmergeList.delete(fingerprint);\n    } else {\n      this.unmergeList.set(fingerprint, eventId);\n      checked = true;\n    }\n\n    // Update \"checked\" state for row\n    this.setStateForId(this.unmergeState, fingerprint, {\n      checked,\n    });\n\n    // Unmerge should be disabled if 0 or all items are selected\n    this.unmergeDisabled = this.unmergeList.size === 0 || this.isAllUnmergedSelected();\n    this.enableFingerprintCompare = this.unmergeList.size === 2;\n\n    this.triggerUnmergeState();\n  },\n\n  onUnmerge({groupId, loadingMessage, successMessage, errorMessage}) {\n    const ids = Array.from(this.unmergeList.keys()) as Array<string>;\n\n    return new Promise((resolve, reject) => {\n      if (this.isAllUnmergedSelected()) {\n        reject(new Error('Not allowed to unmerge ALL events'));\n        return;\n      }\n\n      // Disable unmerge button\n      this.unmergeDisabled = true;\n\n      // Disable rows\n      this.setStateForId(this.unmergeState, ids, {\n        checked: false,\n        busy: true,\n      });\n      this.triggerUnmergeState();\n      addLoadingMessage(loadingMessage);\n\n      this.api.request(`/issues/${groupId}/hashes/`, {\n        method: 'DELETE',\n        query: {\n          id: ids,\n        },\n        success: () => {\n          addSuccessMessage(successMessage);\n\n          // Busy rows after successful merge\n          this.setStateForId(this.unmergeState, ids, {\n            checked: false,\n            busy: true,\n          });\n          this.unmergeList.clear();\n        },\n        error: () => {\n          addErrorMessage(errorMessage);\n          this.setStateForId(this.unmergeState, ids, {\n            checked: true,\n            busy: false,\n          });\n        },\n        complete: () => {\n          this.unmergeDisabled = false;\n          resolve(this.triggerUnmergeState());\n        },\n      });\n    });\n  },\n  // For cross-project views, we need to pass projectId instead of\n  // depending on router params (since we will only have orgId in that case)\n  onMerge({params, query, projectId}) {\n    if (!params) {\n      return undefined;\n    }\n\n    const ids = this.mergeList;\n\n    this.mergeDisabled = true;\n\n    this.setStateForId(this.mergeState, ids as Array<string>, {\n      busy: true,\n    });\n\n    this.triggerMergeState();\n\n    const promise = new Promise(resolve => {\n      // Disable merge button\n      const {orgId, groupId} = params;\n\n      this.api.merge(\n        {\n          orgId,\n          projectId: projectId || params.projectId,\n          itemIds: [...ids, groupId] as Array<number>,\n          query,\n        },\n        {\n          success: data => {\n            if (data?.merge?.parent) {\n              this.trigger({\n                mergedParent: data.merge.parent,\n              });\n            }\n\n            // Hide rows after successful merge\n            this.setStateForId(this.mergeState, ids as Array<string>, {\n              checked: false,\n              busy: true,\n            });\n            this.mergeList = [];\n          },\n          error: () => {\n            this.setStateForId(this.mergeState, ids as Array<string>, {\n              checked: true,\n              busy: false,\n            });\n          },\n          complete: () => {\n            this.mergeDisabled = false;\n            resolve(this.triggerMergeState());\n          },\n        }\n      );\n    });\n\n    return promise;\n  },\n\n  // Toggle collapsed state of all fingerprints\n  onToggleCollapseFingerprints() {\n    this.setStateForId(\n      this.unmergeState,\n      this.mergedItems.map(({id}) => id),\n      {\n        collapsed: !this.unmergeLastCollapsed,\n      }\n    );\n\n    this.unmergeLastCollapsed = !this.unmergeLastCollapsed;\n\n    this.trigger({\n      unmergeLastCollapsed: this.unmergeLastCollapsed,\n      unmergeState: this.unmergeState,\n    });\n  },\n\n  onToggleCollapseFingerprint(fingerprint) {\n    const collapsed =\n      this.unmergeState.has(fingerprint) && this.unmergeState.get(fingerprint).collapsed;\n    this.setStateForId(this.unmergeState, fingerprint, {collapsed: !collapsed});\n    this.trigger({\n      unmergeState: this.unmergeState,\n    });\n  },\n\n  triggerFetchState() {\n    const state = {\n      similarItems: this.similarItems.filter(({isBelowThreshold}) => !isBelowThreshold),\n      filteredSimilarItems: this.similarItems.filter(\n        ({isBelowThreshold}) => isBelowThreshold\n      ),\n      ...pick(this, [\n        'mergedItems',\n        'mergedLinks',\n        'similarLinks',\n        'mergeState',\n        'unmergeState',\n        'loading',\n        'error',\n      ]),\n    };\n    this.trigger(state);\n    return state;\n  },\n\n  triggerUnmergeState() {\n    const state = pick(this, [\n      'unmergeDisabled',\n      'unmergeState',\n      'unmergeList',\n      'enableFingerprintCompare',\n      'unmergeLastCollapsed',\n    ]);\n    this.trigger(state);\n    return state;\n  },\n\n  triggerMergeState() {\n    const state = pick(this, ['mergeDisabled', 'mergeState', 'mergeList']);\n    this.trigger(state);\n    return state;\n  },\n};\n\nexport default Reflux.createStore(storeConfig) as GroupingStore;\n","import PropTypes from 'prop-types';\nimport styled from '@emotion/styled';\n\ntype Props = {\n  /**\n   * Centers content via `justify-content`\n   */\n  center?: boolean;\n  /**\n   * Changes flex direction to be column\n   */\n  vertical?: boolean;\n  /**\n   * Applies \"overflow: hidden\" to container so that children can be truncated\n   */\n  truncate?: boolean;\n};\n\nconst FlowLayout = styled('div')<Props>`\n  display: flex;\n  flex: 1;\n  align-items: center;\n  flex-direction: ${p => (p.vertical ? 'column' : null)};\n  justify-content: ${p => (p.center ? 'center' : null)};\n  overflow: ${p => (p.truncate ? 'hidden' : null)};\n`;\n\nFlowLayout.propTypes = {\n  center: PropTypes.bool,\n  vertical: PropTypes.bool,\n  truncate: PropTypes.bool,\n};\n\nFlowLayout.defaultProps = {\n  truncate: true,\n};\n\nexport default FlowLayout;\n","import PropTypes from 'prop-types';\nimport React from 'react';\nimport classNames from 'classnames';\n\ntype Props = React.HTMLAttributes<HTMLDivElement> & {\n  responsive?: boolean;\n  center?: boolean;\n};\n\n// Flexbox container whose children will have `justify-content: space-between`\n//\n// Intended for children.length === 2\n// \"responsive\" will change flex-direction to be column on small widths\nconst SpreadLayout = ({\n  responsive = false,\n  center = true,\n  children,\n  className,\n  ...props\n}: Props) => {\n  const cx = classNames('spread-layout', className, {\n    center,\n    'allow-responsive': responsive,\n  });\n\n  return (\n    <div {...props} className={cx}>\n      {children}\n    </div>\n  );\n};\n\nSpreadLayout.propTypes = {\n  responsive: PropTypes.bool,\n  center: PropTypes.bool,\n  children: PropTypes.node,\n  style: PropTypes.object,\n};\n\nexport default SpreadLayout;\n","import styled from '@emotion/styled';\n\nconst Toolbar = styled('div')`\n  background: ${p => p.theme.backgroundSecondary};\n  border: 1px solid ${p => p.theme.border};\n  border-bottom: none;\n  border-radius: 3px 3px 0 0;\n  box-shadow: 0 1px 0 ${p => p.theme.border};\n  margin: 0;\n`;\n\nexport default Toolbar;\n","import PropTypes from 'prop-types';\nimport React from 'react';\nimport Reflux from 'reflux';\nimport createReactClass from 'create-react-class';\nimport styled from '@emotion/styled';\n\nimport {IconChevron} from 'app/icons';\nimport Checkbox from 'app/components/checkbox';\nimport EventOrGroupHeader from 'app/components/eventOrGroupHeader';\nimport FlowLayout from 'app/components/flowLayout';\nimport GroupingActions from 'app/actions/groupingActions';\nimport GroupingStore from 'app/stores/groupingStore';\nimport space from 'app/styles/space';\n\nconst MergedItem = createReactClass({\n  displayName: 'MergedItem',\n\n  propTypes: {\n    fingerprint: PropTypes.string.isRequired,\n    disabled: PropTypes.bool,\n    event: PropTypes.shape({\n      id: PropTypes.string,\n      groupID: PropTypes.string,\n      type: PropTypes.oneOf(['error', 'csp', 'default']),\n      dateCreated: PropTypes.string,\n      platform: PropTypes.string,\n    }),\n  },\n\n  mixins: [Reflux.listenTo(GroupingStore, 'onGroupingChange')],\n\n  getInitialState() {\n    return {\n      collapsed: false,\n      checked: false,\n      busy: false,\n    };\n  },\n\n  onGroupingChange({unmergeState}) {\n    if (!unmergeState) {\n      return;\n    }\n\n    const {fingerprint} = this.props;\n    const stateForId = unmergeState.has(fingerprint) && unmergeState.get(fingerprint);\n    if (!stateForId) {\n      return;\n    }\n\n    Object.keys(stateForId).forEach(key => {\n      if (stateForId[key] === this.state[key]) {\n        return;\n      }\n\n      this.setState({\n        [key]: stateForId[key],\n      });\n    });\n  },\n\n  handleToggleEvents() {\n    const {fingerprint} = this.props;\n    GroupingActions.toggleCollapseFingerprint(fingerprint);\n  },\n\n  // Disable default behavior of toggling checkbox\n  handleLabelClick(e) {\n    e.preventDefault();\n  },\n\n  handleToggle() {\n    const {disabled, fingerprint, event} = this.props;\n\n    if (disabled || this.state.busy) {\n      return;\n    }\n\n    // clicking anywhere in the row will toggle the checkbox\n    GroupingActions.toggleUnmerge([fingerprint, event.id]);\n  },\n\n  handleCheckClick() {\n    // noop because of react warning about being a controlled input without `onChange`\n    // we handle change via row click\n  },\n\n  render() {\n    const {disabled, event, fingerprint} = this.props;\n    const checkboxDisabled = disabled || this.state.disabled;\n\n    // `event` can be null if last event w/ fingerprint is not within retention period\n    return (\n      <MergedGroup busy={this.state.busy}>\n        <Controls expanded={!this.state.collapsed}>\n          <FlowLayout onClick={this.handleToggle}>\n            <ActionColumn>\n              <Checkbox\n                id={fingerprint}\n                value={fingerprint}\n                checked={this.state.checked}\n                disabled={checkboxDisabled}\n                onChange={this.handleCheckClick}\n              />\n            </ActionColumn>\n\n            <Fingerprint onClick={this.handleLabelClick} htmlFor={fingerprint}>\n              {fingerprint}\n            </Fingerprint>\n          </FlowLayout>\n\n          <div>\n            <span />\n            <Collapse onClick={this.handleToggleEvents}>\n              {this.state.collapsed ? (\n                <IconChevron direction=\"down\" size=\"xs\" />\n              ) : (\n                <IconChevron direction=\"up\" size=\"xs\" />\n              )}\n            </Collapse>\n          </div>\n        </Controls>\n\n        {!this.state.collapsed && (\n          <MergedEventList className=\"event-list\">\n            {event && (\n              <EventDetails className=\"event-details\">\n                <FlowLayout>\n                  <EventOrGroupHeader data={event} hideIcons hideLevel />\n                </FlowLayout>\n              </EventDetails>\n            )}\n          </MergedEventList>\n        )}\n      </MergedGroup>\n    );\n  },\n});\n\nconst MergedGroup = styled('div')`\n  ${p => p.busy && 'opacity: 0.2'};\n`;\n\nconst ActionColumn = styled('div')`\n  display: flex;\n  padding: 0 10px;\n  align-items: center;\n\n  input {\n    margin: 0;\n  }\n`;\n\nconst Controls = styled('div')`\n  display: flex;\n  justify-content: space-between;\n  border-top: 1px solid ${p => p.theme.innerBorder};\n  background-color: #f3f1f6;\n  padding: ${space(0.5)} 0;\n  ${p => p.expanded && `border-bottom: 1px solid ${p.theme.innerBorder}`};\n\n  ${MergedGroup} {\n    &:first-child & {\n      border-top: none;\n    }\n    &:last-child & {\n      border-top: none;\n      border-bottom: 1px solid ${p => p.theme.innerBorder};\n    }\n  }\n`;\n\nconst Fingerprint = styled('label')`\n  font-family: ${p => p.theme.text.familyMono};\n\n  ${/* sc-selector */ Controls} & {\n    font-weight: normal;\n    margin: 0;\n  }\n`;\n\nconst Collapse = styled('span')`\n  cursor: pointer;\n  padding: 0 10px;\n`;\n\nconst MergedEventList = styled('div')`\n  overflow: hidden;\n  border: none;\n`;\n\nconst EventDetails = styled('div')`\n  display: flex;\n  justify-content: space-between;\n\n  .event-list & {\n    padding: 10px;\n  }\n`;\n\nexport default MergedItem;\n","import PropTypes from 'prop-types';\nimport React from 'react';\nimport Reflux from 'reflux';\nimport pick from 'lodash/pick';\nimport createReactClass from 'create-react-class';\nimport styled from '@emotion/styled';\n\nimport {openDiffModal} from 'app/actionCreators/modal';\nimport {t} from 'app/locale';\nimport Button from 'app/components/button';\nimport GroupingStore from 'app/stores/groupingStore';\nimport LinkWithConfirmation from 'app/components/links/linkWithConfirmation';\nimport SpreadLayout from 'app/components/spreadLayout';\nimport Toolbar from 'app/components/toolbar';\nimport space from 'app/styles/space';\nimport SentryTypes from 'app/sentryTypes';\n\nconst MergedToolbar = createReactClass({\n  displayName: 'MergedToolbar',\n\n  propTypes: {\n    orgId: PropTypes.string.isRequired,\n    project: SentryTypes.Project.isRequired,\n    groupId: PropTypes.string,\n    onUnmerge: PropTypes.func,\n    onToggleCollapse: PropTypes.func,\n  },\n\n  mixins: [Reflux.listenTo(GroupingStore, 'onGroupingUpdate')],\n\n  getInitialState() {\n    const {\n      unmergeList,\n      unmergeLastCollapsed,\n      unmergeDisabled,\n      enableFingerprintCompare,\n    } = GroupingStore;\n\n    return {\n      enableFingerprintCompare,\n      unmergeList,\n      unmergeLastCollapsed,\n      unmergeDisabled,\n    };\n  },\n\n  onGroupingUpdate(updateObj) {\n    const allowedKeys = [\n      'unmergeLastCollapsed',\n      'unmergeDisabled',\n      'unmergeList',\n      'enableFingerprintCompare',\n    ];\n\n    this.setState(pick(updateObj, allowedKeys));\n  },\n\n  handleShowDiff(e) {\n    const {groupId, project, orgId} = this.props;\n    const entries = this.state.unmergeList.entries();\n\n    // `unmergeList` should only have 2 items in map\n    if (this.state.unmergeList.size !== 2) {\n      return;\n    }\n\n    // only need eventId, not fingerprint\n    const [baseEventId, targetEventId] = Array.from(entries).map(\n      ([, eventId]) => eventId\n    );\n\n    openDiffModal({\n      baseIssueId: groupId,\n      targetIssueId: groupId,\n      baseEventId,\n      targetEventId,\n      orgId,\n      project,\n    });\n\n    e.stopPropagation();\n  },\n\n  render() {\n    const {onUnmerge, onToggleCollapse} = this.props;\n    const unmergeCount = (this.state.unmergeList && this.state.unmergeList.size) || 0;\n\n    return (\n      <StyledToolbar>\n        <SpreadLayout>\n          <SpreadLayout>\n            <div>\n              <LinkWithConfirmation\n                disabled={this.state.unmergeDisabled}\n                title={t(`Unmerging ${unmergeCount} events`)}\n                message={t(\n                  'These events will be unmerged and grouped into a new issue. Are you sure you want to unmerge these events?'\n                )}\n                className=\"btn btn-sm btn-default\"\n                onConfirm={onUnmerge}\n              >\n                {t('Unmerge')} ({unmergeCount || 0})\n              </LinkWithConfirmation>\n\n              <CompareButton\n                size=\"small\"\n                disabled={!this.state.enableFingerprintCompare}\n                onClick={this.handleShowDiff}\n              >\n                {t('Compare')}\n              </CompareButton>\n            </div>\n          </SpreadLayout>\n          <SpreadLayout>\n            <div>\n              <Button size=\"small\" onClick={onToggleCollapse}>\n                {this.state.unmergeLastCollapsed ? t('Expand All') : t('Collapse All')}\n              </Button>\n            </div>\n          </SpreadLayout>\n        </SpreadLayout>\n      </StyledToolbar>\n    );\n  },\n});\n\nconst CompareButton = styled(Button)`\n  margin-left: ${space(1)};\n`;\n\nconst StyledToolbar = styled(Toolbar)`\n  padding: ${space(0.5)} ${space(1)};\n`;\n\nexport default MergedToolbar;\n","import PropTypes from 'prop-types';\nimport React from 'react';\nimport styled from '@emotion/styled';\n\nimport {Panel} from 'app/components/panels';\nimport {t} from 'app/locale';\nimport EmptyStateWarning from 'app/components/emptyStateWarning';\nimport Pagination from 'app/components/pagination';\nimport QueryCount from 'app/components/queryCount';\nimport SentryTypes from 'app/sentryTypes';\n\nimport MergedItem from './mergedItem';\nimport MergedToolbar from './mergedToolbar';\n\nclass MergedList extends React.Component {\n  static propTypes = {\n    onUnmerge: PropTypes.func.isRequired,\n    onToggleCollapse: PropTypes.func.isRequired,\n    items: PropTypes.arrayOf(SentryTypes.Event),\n    pageLinks: PropTypes.string,\n    orgId: PropTypes.string.isRequired,\n    project: SentryTypes.Project.isRequired,\n  };\n\n  renderEmpty = () => (\n    <EmptyStateWarning>\n      <p>{t(\"There don't seem to be any hashes for this issue.\")}</p>\n    </EmptyStateWarning>\n  );\n\n  render() {\n    const {items, pageLinks, onToggleCollapse, onUnmerge, orgId, project} = this.props;\n    const itemsWithLatestEvent = items.filter(({latestEvent}) => !!latestEvent);\n    const hasResults = itemsWithLatestEvent.length > 0;\n\n    if (!hasResults) {\n      return <Panel>{this.renderEmpty()}</Panel>;\n    }\n\n    return (\n      <div>\n        <h2>\n          <span>{t('Merged fingerprints with latest event')}</span>\n          <QueryCount count={itemsWithLatestEvent.length} />\n        </h2>\n\n        <MergedToolbar\n          onToggleCollapse={onToggleCollapse}\n          onUnmerge={onUnmerge}\n          orgId={orgId}\n          project={project}\n        />\n\n        <MergedItems>\n          {itemsWithLatestEvent.map(({id, latestEvent}) => (\n            <MergedItem\n              key={id}\n              orgId={orgId}\n              projectId={project.slug}\n              disabled={items.length === 1}\n              event={latestEvent}\n              fingerprint={id}\n            />\n          ))}\n        </MergedItems>\n\n        <Pagination pageLinks={pageLinks} />\n      </div>\n    );\n  }\n}\n\nexport default MergedList;\n\nconst MergedItems = styled('div')`\n  border: 1px solid ${p => p.theme.border};\n  border-top: none;\n`;\n","import React from 'react';\nimport Reflux from 'reflux';\nimport createReactClass from 'create-react-class';\nimport * as queryString from 'query-string';\n\nimport {t} from 'app/locale';\nimport Alert from 'app/components/alert';\nimport GroupingActions from 'app/actions/groupingActions';\nimport GroupingStore from 'app/stores/groupingStore';\nimport LoadingError from 'app/components/loadingError';\nimport LoadingIndicator from 'app/components/loadingIndicator';\nimport SentryTypes from 'app/sentryTypes';\n\nimport MergedList from './mergedList';\n\nconst GroupMergedView = createReactClass({\n  displayName: 'GroupMergedView',\n  propTypes: {\n    project: SentryTypes.Project,\n  },\n  mixins: [Reflux.listenTo(GroupingStore, 'onGroupingUpdate')],\n\n  getInitialState() {\n    const queryParams = this.props.location.query;\n    return {\n      mergedItems: [],\n      loading: true,\n      error: false,\n      query: queryParams.query || '',\n    };\n  },\n\n  componentWillMount() {\n    this.fetchData();\n  },\n\n  componentWillReceiveProps(nextProps) {\n    if (\n      nextProps.params.groupId !== this.props.params.groupId ||\n      nextProps.location.search !== this.props.location.search\n    ) {\n      const queryParams = nextProps.location.query;\n      this.setState(\n        {\n          query: queryParams.query,\n        },\n        this.fetchData\n      );\n    }\n  },\n\n  onGroupingUpdate({mergedItems, mergedLinks, loading, error}) {\n    if (mergedItems) {\n      this.setState({\n        mergedItems,\n        mergedLinks,\n        loading: typeof loading !== 'undefined' ? loading : false,\n        error: typeof error !== 'undefined' ? error : false,\n      });\n    }\n  },\n\n  getEndpoint(type = 'hashes') {\n    const params = this.props.params;\n    const queryParams = {\n      ...this.props.location.query,\n      limit: 50,\n      query: this.state.query,\n    };\n\n    return `/issues/${params.groupId}/${type}/?${queryString.stringify(queryParams)}`;\n  },\n\n  fetchData() {\n    GroupingActions.fetch([\n      {\n        endpoint: this.getEndpoint('hashes'),\n        dataKey: 'merged',\n        queryParams: this.props.location.query,\n      },\n    ]);\n  },\n\n  handleCollapse() {\n    GroupingActions.collapseFingerprints();\n  },\n\n  handleUnmerge() {\n    GroupingActions.unmerge({\n      groupId: this.props.params.groupId,\n      loadingMessage: `${t('Unmerging events')}...`,\n      successMessage: t('Events successfully queued for unmerging.'),\n      errorMessage: t('Unable to queue events for unmerging.'),\n    });\n  },\n\n  render() {\n    const isLoading = this.state.loading;\n    const isError = this.state.error && !isLoading;\n    const isLoadedSuccessfully = !isError && !isLoading;\n\n    return (\n      <div>\n        <Alert type=\"warning\">\n          {t(\n            'This is an experimental feature. Data may not be immediately available while we process unmerges.'\n          )}\n        </Alert>\n\n        {isLoading && <LoadingIndicator />}\n        {isError && (\n          <LoadingError\n            message=\"Unable to load merged events, please try again later\"\n            onRetry={this.fetchData}\n          />\n        )}\n\n        {isLoadedSuccessfully && (\n          <MergedList\n            orgId={this.props.params.orgId}\n            project={this.props.project}\n            items={this.state.mergedItems}\n            pageLinks={this.state.mergedLinks}\n            onUnmerge={this.handleUnmerge}\n            onToggleCollapse={GroupingActions.toggleCollapseFingerprints}\n          />\n        )}\n      </div>\n    );\n  },\n});\n\nexport {GroupMergedView};\n\nexport default GroupMergedView;\n"],"sourceRoot":""}