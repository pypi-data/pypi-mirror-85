{"version":3,"sources":["webpack:///./app/components/charts/lineChart.jsx","webpack:///./app/components/charts/chartZoom.jsx","webpack:///./app/components/charts/areaChart.tsx","webpack:///./app/components/charts/releaseSeries.jsx","webpack:///./app/utils/getPeriod.tsx","webpack:///./app/components/charts/series/areaSeries.tsx"],"names":["LineChart","this","props","series","seriesOptions","map","seriesName","data","dataArray","options","LineSeries","name","value","animation","animationThreshold","animationDuration","React","Component","getDate","date","moment","utc","format","HTML5_FMT","DATETIME_LOCAL_SECONDS","ChartZoom","saveCurrentPeriod","currentPeriod","period","start","end","setPeriod","saveHistory","router","onZoom","startFormatted","endFormatted","history","push","callIfFunction","zooming","updateDateTime","getUtcToLocalDateObject","handleChartReady","chart","dispatchAction","type","key","dataZoomSelectActive","onChartReady","handleZoomRestore","evt","length","onRestore","handleDataZoom","axis","getModel","option","xAxis","rangeStart","rangeEnd","previousPeriod","pop","onDataZoom","handleChartFinished","onFinished","disabled","children","xAxisIndex","isGroupedByDate","dataZoom","DataZoomInside","showTimeInTooltip","toolBox","ToolBox","title","zoom","back","iconStyle","borderWidth","color","opacity","AreaChart","stacked","colors","i","otherSeriesProps","AreaSeries","stack","undefined","lineStyle","width","areaStyle","getOrganizationReleases","api","organization","a","conditions","query","Object","keys","forEach","getUtcDateString","clear","requestPromise","slug","includeAllArgs","method","ReleaseSeries","state","releases","releaseSeries","getOrganizationReleasesMemoized","memoize","_","__","values","JSON","stringify","join","getReleaseSeries","tooltip","markLine","MarkLine","normal","theme","purple300","trigger","formatter","time","getFormattedDate","local","version","escape","formatVersion","t","label","show","release","Date","onClick","pathname","Set","features","has","project","location","_isMounted","setReleasesWithSeries","fetchData","prevProps","isEqual","projects","environments","memoized","environment","statsPeriod","hasMore","getReleases","newReleases","xhr","pageLinks","getResponseHeader","paginationObject","parseLinkHeader","next","results","cursor","addErrorMessage","setState","withRouter","withOrganization","withApi","getPeriod","shouldDoublePeriod","DEFAULT_STATS_PERIOD","match","periodNumber","periodLength","parseInt","Error","formattedStart","formattedEnd","diff","previousPeriodStart","subtract"],"mappings":"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","file":"DiscoverV2Results~Events~OverviewDashboard~PerformanceCompareTransactions~PerformanceLanding~Perform~d3539a9e.js","sourcesContent":["import PropTypes from 'prop-types';\nimport React from 'react';\n\nimport BaseChart from './baseChart';\nimport LineSeries from './series/lineSeries';\n\nexport default class LineChart extends React.Component {\n  static propTypes = {\n    ...BaseChart.propTypes,\n    seriesOptions: PropTypes.object,\n  };\n\n  render() {\n    const {series, seriesOptions, ...props} = this.props;\n\n    return (\n      <BaseChart\n        {...props}\n        series={series.map(({seriesName, data, dataArray, ...options}) =>\n          LineSeries({\n            ...seriesOptions,\n            ...options,\n            name: seriesName,\n            data: dataArray || data.map(({value, name}) => [name, value]),\n            animation: false,\n            animationThreshold: 1,\n            animationDuration: 0,\n          })\n        )}\n      />\n    );\n  }\n}\n","import PropTypes from 'prop-types';\nimport React from 'react';\nimport moment from 'moment';\n\nimport {callIfFunction} from 'app/utils/callIfFunction';\nimport {getUtcToLocalDateObject} from 'app/utils/dates';\nimport {updateDateTime} from 'app/actionCreators/globalSelection';\nimport DataZoomInside from 'app/components/charts/components/dataZoomInside';\nimport SentryTypes from 'app/sentryTypes';\nimport ToolBox from 'app/components/charts/components/toolBox';\n\nconst getDate = date =>\n  date ? moment.utc(date).format(moment.HTML5_FMT.DATETIME_LOCAL_SECONDS) : null;\n\n/**\n * This is a very opinionated component that takes a render prop through `children`. It\n * will provide props to be passed to `BaseChart` to enable support of zooming without\n * eCharts' clunky zoom toolboxes.\n *\n * This also is very tightly coupled with the Global Selection Header. We can make it more\n * generic if need be in the future.\n */\nclass ChartZoom extends React.Component {\n  static propTypes = {\n    router: PropTypes.object,\n    period: PropTypes.string,\n    start: PropTypes.instanceOf(Date),\n    end: PropTypes.instanceOf(Date),\n    utc: PropTypes.bool,\n    disabled: PropTypes.bool,\n\n    xAxis: SentryTypes.EChartsXAxis,\n    /**\n     * If you need the dataZoom control to control more than one chart.\n     * you can provide a list of the axis indexes.\n     */\n    xAxisIndex: PropTypes.arrayOf(PropTypes.number),\n\n    // Callback for when chart has been zoomed\n    onZoom: PropTypes.func,\n    // Callbacks for eCharts events\n    onRestore: PropTypes.func,\n    onChartReady: PropTypes.func,\n    onDataZoom: PropTypes.func,\n    onFinished: PropTypes.func,\n  };\n\n  constructor(props) {\n    super(props);\n\n    // Zoom history\n    this.history = [];\n\n    // Initialize current period instance state for zoom history\n    this.saveCurrentPeriod(props);\n  }\n\n  componentDidUpdate() {\n    if (this.props.disabled) {\n      return;\n    }\n\n    // When component updates, make sure we sync current period state\n    // for use in zoom history\n    this.saveCurrentPeriod(this.props);\n  }\n\n  /**\n   * Save current period state from period in props to be used\n   * in handling chart's zoom history state\n   */\n  saveCurrentPeriod = props => {\n    this.currentPeriod = {\n      period: props.period,\n      start: getDate(props.start),\n      end: getDate(props.end),\n    };\n  };\n\n  /**\n   * Sets the new period due to a zoom related action\n   *\n   * Saves the current period to an instance property so that we\n   * can control URL state when zoom history is being manipulated\n   * by the chart controls.\n   *\n   * Saves a callback function to be called after chart animation is completed\n   */\n  setPeriod = ({period, start, end}, saveHistory) => {\n    const {router, onZoom} = this.props;\n    const startFormatted = getDate(start);\n    const endFormatted = getDate(end);\n\n    // Save period so that we can revert back to it when using echarts \"back\" navigation\n    if (saveHistory) {\n      this.history.push(this.currentPeriod);\n    }\n\n    // Callback to let parent component know zoom has changed\n    // This is required for some more perceived responsiveness since\n    // we delay updating URL state so that chart animation can finish\n    //\n    // Parent container can use this to change into a loading state before\n    // URL parameters are changed\n    callIfFunction(onZoom, {\n      period,\n      start: startFormatted,\n      end: endFormatted,\n    });\n\n    this.zooming = () => {\n      updateDateTime(\n        {\n          period,\n          start: startFormatted\n            ? getUtcToLocalDateObject(startFormatted)\n            : startFormatted,\n          end: endFormatted ? getUtcToLocalDateObject(endFormatted) : endFormatted,\n        },\n        router\n      );\n\n      this.saveCurrentPeriod({period, start, end});\n    };\n  };\n\n  /**\n   * Enable zoom immediately instead of having to toggle to zoom\n   */\n  handleChartReady = chart => {\n    chart.dispatchAction({\n      type: 'takeGlobalCursor',\n      key: 'dataZoomSelect',\n      dataZoomSelectActive: true,\n    });\n\n    callIfFunction(this.props.onChartReady, chart);\n  };\n\n  /**\n   * Restores the chart to initial viewport/zoom level\n   *\n   * Updates URL state to reflect initial params\n   */\n  handleZoomRestore = (evt, chart) => {\n    if (!this.history.length) {\n      return;\n    }\n\n    this.setPeriod(this.history[0]);\n\n    // reset history\n    this.history = [];\n\n    callIfFunction(this.props.onRestore, evt, chart);\n  };\n\n  handleDataZoom = (evt, chart) => {\n    const model = chart.getModel();\n    const {xAxis} = model.option;\n    const axis = xAxis[0];\n\n    // if `rangeStart` and `rangeEnd` are null, then we are going back\n    if (axis.rangeStart === null && axis.rangeEnd === null) {\n      const previousPeriod = this.history.pop();\n\n      if (!previousPeriod) {\n        return;\n      }\n\n      this.setPeriod(previousPeriod);\n    } else {\n      const start = moment.utc(axis.rangeStart);\n\n      // Add a day so we go until the end of the day (e.g. next day at midnight)\n      const end = moment.utc(axis.rangeEnd);\n\n      this.setPeriod({period: null, start, end}, true);\n    }\n\n    callIfFunction(this.props.onDataZoom, evt, chart);\n  };\n\n  /**\n   * Chart event when *any* rendering+animation finishes\n   *\n   * `this.zooming` acts as a callback function so that\n   * we can let the native zoom animation on the chart complete\n   * before we update URL state and re-render\n   */\n  handleChartFinished = () => {\n    if (typeof this.zooming === 'function') {\n      this.zooming();\n      this.zooming = null;\n    }\n    callIfFunction(this.props.onFinished);\n  };\n\n  render() {\n    const {\n      utc,\n      disabled,\n      children,\n      xAxisIndex,\n\n      onZoom: _onZoom,\n      onRestore: _onRestore,\n      onChartReady: _onChartReady,\n      onDataZoom: _onDataZoom,\n      onFinished: _onFinished,\n      ...props\n    } = this.props;\n\n    if (disabled) {\n      return children(props);\n    }\n\n    // TODO(mark) Update consumers of DataZoom when typing this.\n    const renderProps = {\n      // Zooming only works when grouped by date\n      isGroupedByDate: true,\n      onChartReady: this.handleChartReady,\n      utc,\n      dataZoom: DataZoomInside({xAxisIndex}),\n      showTimeInTooltip: true,\n      toolBox: ToolBox(\n        {},\n        {\n          dataZoom: {\n            title: {\n              zoom: '',\n              back: '',\n            },\n            iconStyle: {\n              borderWidth: 0,\n              color: 'transparent',\n              opacity: 0,\n            },\n          },\n        }\n      ),\n      onDataZoom: this.handleDataZoom,\n      onRestore: this.handleZoomRestore,\n      onFinished: this.handleChartFinished,\n      ...props,\n    };\n\n    return children(renderProps);\n  }\n}\n\nexport default ChartZoom;\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport {EChartOption} from 'echarts';\n\nimport {Series} from 'app/types/echarts';\n\nimport AreaSeries from './series/areaSeries';\nimport BaseChart from './baseChart';\n\ntype ChartProps = React.ComponentProps<typeof BaseChart>;\n\nexport type AreaChartSeries = Series & Omit<EChartOption.SeriesLine, 'data' | 'name'>;\n\ntype Props = Omit<ChartProps, 'series'> & {\n  stacked?: boolean;\n  series: AreaChartSeries[];\n};\n\nclass AreaChart extends React.Component<Props> {\n  static propTypes = {\n    ...BaseChart.propTypes,\n    stacked: PropTypes.bool,\n  };\n\n  render() {\n    const {series, stacked, colors, ...props} = this.props;\n\n    return (\n      <BaseChart\n        {...props}\n        series={series.map(({seriesName, data, ...otherSeriesProps}, i) =>\n          AreaSeries({\n            stack: stacked ? 'area' : undefined,\n            name: seriesName,\n            data: data.map(({name, value}) => [name, value]),\n            color: colors && colors[i],\n            lineStyle: {\n              opacity: 1,\n              width: 0.4,\n            },\n            areaStyle: {\n              color: colors && colors[i],\n              opacity: 1.0,\n            },\n            animation: false,\n            animationThreshold: 1,\n            animationDuration: 0,\n            ...otherSeriesProps,\n          })\n        )}\n      />\n    );\n  }\n}\n\nexport default AreaChart;\n","import {withRouter} from 'react-router';\nimport PropTypes from 'prop-types';\nimport React from 'react';\nimport isEqual from 'lodash/isEqual';\nimport memoize from 'lodash/memoize';\n\nimport {addErrorMessage} from 'app/actionCreators/indicator';\nimport {getFormattedDate, getUtcDateString} from 'app/utils/dates';\nimport {t} from 'app/locale';\nimport MarkLine from 'app/components/charts/components/markLine';\nimport SentryTypes from 'app/sentryTypes';\nimport theme from 'app/utils/theme';\nimport withApi from 'app/utils/withApi';\nimport withOrganization from 'app/utils/withOrganization';\nimport parseLinkHeader from 'app/utils/parseLinkHeader';\nimport {escape} from 'app/utils';\nimport {formatVersion} from 'app/utils/formatters';\n\n// This is not an exported action/function because releases list uses AsyncComponent\n// and this is not re-used anywhere else afaict\nasync function getOrganizationReleases(api, organization, conditions = null) {\n  const query = {};\n  Object.keys(conditions).forEach(key => {\n    let value = conditions[key];\n    if (value && (key === 'start' || key === 'end')) {\n      value = getUtcDateString(value);\n    }\n    if (value) {\n      query[key] = value;\n    }\n  });\n  api.clear();\n  return api.requestPromise(`/organizations/${organization.slug}/releases/stats/`, {\n    includeAllArgs: true,\n    method: 'GET',\n    query,\n  });\n}\n\nclass ReleaseSeries extends React.Component {\n  static propTypes = {\n    api: PropTypes.object,\n    router: PropTypes.object,\n    organization: SentryTypes.Organization,\n    projects: PropTypes.arrayOf(PropTypes.number),\n    environments: PropTypes.arrayOf(PropTypes.string),\n\n    period: PropTypes.string,\n    start: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.string]),\n    end: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.string]),\n    utc: PropTypes.bool,\n    // Array of releases, if empty, component will fetch releases itself\n    releases: PropTypes.arrayOf(SentryTypes.Release),\n    tooltip: SentryTypes.EChartsTooltip,\n\n    memoized: PropTypes.bool,\n  };\n\n  state = {\n    releases: null,\n    releaseSeries: [],\n  };\n\n  componentDidMount() {\n    this._isMounted = true;\n    const {releases} = this.props;\n\n    if (releases) {\n      // No need to fetch releases if passed in from props\n      this.setReleasesWithSeries(releases);\n      return;\n    }\n\n    this.fetchData();\n  }\n\n  componentDidUpdate(prevProps) {\n    if (\n      !isEqual(prevProps.projects, this.props.projects) ||\n      !isEqual(prevProps.environments, this.props.environments) ||\n      !isEqual(prevProps.start, this.props.start) ||\n      !isEqual(prevProps.end, this.props.end) ||\n      !isEqual(prevProps.period, this.props.period)\n    ) {\n      this.fetchData();\n    }\n  }\n\n  componentWillUnmount() {\n    this._isMounted = false;\n    this.props.api.clear();\n  }\n\n  getOrganizationReleasesMemoized = memoize(\n    async (api, conditions, organization) =>\n      await getOrganizationReleases(api, conditions, organization),\n    (_, __, conditions) => `${Object.values(conditions).map(JSON.stringify).join('-')}`\n  );\n\n  async fetchData() {\n    const {\n      api,\n      organization,\n      projects,\n      environments,\n      period,\n      start,\n      end,\n      memoized,\n    } = this.props;\n    const conditions = {\n      start,\n      end,\n      project: projects,\n      environment: environments,\n      statsPeriod: period,\n    };\n    let hasMore = true;\n    const releases = [];\n    while (hasMore) {\n      try {\n        const getReleases = memoized\n          ? this.getOrganizationReleasesMemoized\n          : getOrganizationReleases;\n        const [newReleases, , xhr] = await getReleases(api, organization, conditions);\n        releases.push(...newReleases);\n        if (this._isMounted) {\n          this.setReleasesWithSeries(releases);\n        }\n\n        const pageLinks = xhr && xhr.getResponseHeader('Link');\n        if (pageLinks) {\n          const paginationObject = parseLinkHeader(pageLinks);\n          hasMore = paginationObject && paginationObject.next.results;\n          conditions.cursor = paginationObject.next.cursor;\n        } else {\n          hasMore = false;\n        }\n      } catch {\n        addErrorMessage(t('Error fetching releases'));\n        hasMore = false;\n      }\n    }\n  }\n\n  setReleasesWithSeries(releases) {\n    this.setState({\n      releases,\n      releaseSeries: [this.getReleaseSeries(releases)],\n    });\n  }\n\n  getReleaseSeries = releases => {\n    const {organization, router, tooltip} = this.props;\n\n    return {\n      seriesName: 'Releases',\n      data: [],\n      markLine: MarkLine({\n        animation: false,\n        lineStyle: {\n          normal: {\n            color: theme.purple300,\n            opacity: 0.3,\n            type: 'solid',\n          },\n        },\n        tooltip: tooltip || {\n          trigger: 'item',\n          formatter: ({data}) => {\n            // XXX using this.props here as this function does not get re-run\n            // unless projects are changed. Using a closure variable would result\n            // in stale values.\n            const time = getFormattedDate(data.value, 'MMM D, YYYY LT', {\n              local: !this.props.utc,\n            });\n            const version = escape(formatVersion(data.name, true));\n            return [\n              '<div class=\"tooltip-series\">',\n              `<div><span class=\"tooltip-label\"><strong>${t(\n                'Release'\n              )}</strong></span> ${version}</div>`,\n              '</div>',\n              '<div class=\"tooltip-date\">',\n              time,\n              '</div>',\n              '</div>',\n              '<div class=\"tooltip-arrow\"></div>',\n            ].join('');\n          },\n        },\n        label: {\n          show: false,\n        },\n        data: releases.map(release => ({\n          xAxis: +new Date(release.date),\n          name: formatVersion(release.version, true),\n          value: formatVersion(release.version, true),\n          onClick: () => {\n            router.push({\n              pathname: `/organizations/${organization.slug}/releases/${release.version}/`,\n              query: new Set(organization.features).has('global-views')\n                ? undefined\n                : {project: router.location.query.project},\n            });\n          },\n          label: {\n            formatter: () => formatVersion(release.version, true),\n          },\n        })),\n      }),\n    };\n  };\n\n  render() {\n    const {children} = this.props;\n\n    return children({\n      releases: this.state.releases,\n      releaseSeries: this.state.releaseSeries,\n    });\n  }\n}\n\nexport default withRouter(withOrganization(withApi(ReleaseSeries)));\n","import moment from 'moment';\n\nimport {DEFAULT_STATS_PERIOD} from 'app/constants';\nimport {getUtcDateString} from 'app/utils/dates';\n\n/**\n * Gets the period to query with if we need to double the initial period in order\n * to get data for the previous period\n *\n * @param {Object} dateObj The date object\n * @param {String} dateObj.period Relative period string in format \"<int><unit>\" (e.g. 4d for 4 days)\n * @param {Date} dateObj.start Starting date object\n * @param {Date} dateObj.end Ending date object\n * @param {Object} options Options\n * @param {Boolean} [options.shouldDoublePeriod] Doubles the given period (useful for getting previous period data)\n * @return {Object} Returns an object with either a period or start/end dates ({statsPeriod: string} or {start: string, end: string})\n */\ntype Options = {shouldDoublePeriod?: boolean};\n\nexport const getPeriod = (\n  {period, start, end},\n  {shouldDoublePeriod}: Options = {}\n): {start: string; end: string} | {statsPeriod: string} => {\n  if (!period && !start && !end) {\n    period = DEFAULT_STATS_PERIOD;\n  }\n\n  // you can not specify both relative and absolute periods\n  // relative period takes precedence\n  if (period) {\n    if (!shouldDoublePeriod) {\n      return {statsPeriod: period};\n    }\n    const [, periodNumber, periodLength] = period.match(/([0-9]+)([mhdw])/);\n\n    return {statsPeriod: `${parseInt(periodNumber, 10) * 2}${periodLength}`};\n  }\n\n  if (!start || !end) {\n    throw new Error('start and end required');\n  }\n\n  const formattedStart = getUtcDateString(start);\n  const formattedEnd = getUtcDateString(end);\n\n  if (shouldDoublePeriod) {\n    // get duration of end - start and double\n    const diff = moment(end).diff(moment(start));\n\n    const previousPeriodStart = moment(start).subtract(diff);\n\n    // This is not as accurate as having 2 start/end objs\n    return {\n      start: getUtcDateString(previousPeriodStart),\n      end: formattedEnd,\n    };\n  }\n\n  return {\n    start: formattedStart,\n    end: formattedEnd,\n  };\n};\n","import {EChartOption} from 'echarts';\n\nimport LineSeries from 'app/components/charts/series/lineSeries';\n\nexport default function AreaSeries(\n  props: EChartOption.SeriesLine = {}\n): EChartOption.SeriesLine {\n  return LineSeries({\n    ...props,\n  });\n}\n"],"sourceRoot":""}