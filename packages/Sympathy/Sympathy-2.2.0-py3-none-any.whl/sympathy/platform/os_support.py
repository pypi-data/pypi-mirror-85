# This file is part of Sympathy for Data.
# Copyright (c) 2017, Combine Control Systems AB
#
# Sympathy for Data is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, version 3 of the License.
#
# Sympathy for Data is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Sympathy for Data.  If not, see <http://www.gnu.org/licenses/>.
import os
import sys
import ctypes
import threading
import subprocess
import re
import logging
import importlib
import shutil
import codecs

from sympathy.platform import editor as editor_api
from sympathy.utils import prim
from . import qt_compat2 as qt

QtCore = qt.QtCore
core_logger = logging.getLogger('core')
cygcore = re.compile('^processor[\t]*: [0-9]*.*$')
fs_encoding = sys.getfilesystemencoding()


APP_DESKTOP_CONTENTS = """
[Desktop Entry]
Name=Sympathy for Data
Type=Application
MimeType=application/x-sympathy-workflow+xml
Exec={python_exec} -I -m sympathy gui %f
Icon={icon_path}
""".strip()

VIEWER_DESKTOP_CONTENTS = """
[Desktop Entry]
Name=Sympathy for Data viewer
Type=Application
MimeType=application/x-sympathy-sydata
Exec={python_exec} -I -m sympathy viewer %f
Icon={icon_path}
NoDisplay=true
""".strip()

SYX_MIME_TYPE_CONTENTS = """
<?xml version="1.0" encoding="UTF-8"?>
<mime-info xmlns="http://www.freedesktop.org/standards/shared-mime-info">
<mime-type type="application/x-sympathy-workflow+xml">
<comment>Sympathy for Data workflow</comment>
<glob pattern="*.syx"/>
</mime-type>
</mime-info>
""".strip()

SYDATA_MIME_TYPE_CONTENTS = """
<?xml version="1.0" encoding="UTF-8"?>
<mime-info xmlns="http://www.freedesktop.org/standards/shared-mime-info">
<mime-type type="application/x-sympathy-sydata">
<comment>Sympathy for Data data file</comment>
<glob pattern="*.sydata"/>
</mime-type>
</mime-info>
""".strip()


def create_desktop_entries():
    """Create a desktop entry for Sympathy main gui and viewer."""
    if not prim.is_linux():
        print("This is not Linux!")
        return

    home = os.path.expanduser('~')
    folder = os.path.join(home, '.local', 'share', 'applications')

    filename = 'com.sympathyfordata.SympathyForData.desktop'
    contents = APP_DESKTOP_CONTENTS.format(
        python_exec=sys.executable,
        icon_path=prim.get_icon_path('application.ico'))
    with open(os.path.join(folder, filename), 'w') as f:
        f.write(contents)

    filename = 'com.sympathyfordata.SympathyForDataViewer.desktop'
    contents = VIEWER_DESKTOP_CONTENTS.format(
        python_exec=sys.executable,
        icon_path=prim.get_icon_path('application.ico'))
    with open(os.path.join(folder, filename), 'w') as f:
        f.write(contents)


def create_mime_type_associations():
    """Create a mime type definition for syx files."""
    if not prim.is_linux():
        print("This is not Linux!")
        return

    home = os.path.expanduser('~')
    folder = os.path.join(home, '.local', 'share', 'mime', 'packages')

    filename = 'application-x-sympathy-workflow.xml'
    with open(os.path.join(folder, filename), 'w') as f:
        f.write(SYX_MIME_TYPE_CONTENTS)

    filename = 'application-x-sympathy-sydata.xml'
    with open(os.path.join(folder, filename), 'w') as f:
        f.write(SYDATA_MIME_TYPE_CONTENTS)


def delete_desktop_entry():
    """Delete the desktop entry generated by create_desktop_entry."""
    folder = os.path.expanduser(
        os.path.join('~', '.local', 'share', 'applications'))

    for filename in ['com.sympathyfordata.SympathyForData.desktop',
                     'com.sympathyfordata.SympathyForDataViewer.desktop']:
        try:
            os.unlink(os.path.join(folder, filename))
        except (IOError, OSError):
            pass


def delete_mime_type_association():
    """Delete the mime type generated by create_mime_type_association."""
    if not prim.is_linux():
        print("This is not Linux!")
        return

    home = os.path.expanduser('~')
    folder = os.path.join(home, '.local', 'share', 'mime', 'packages')

    for filename in ['application-x-sympathy-workflow.xml',
                     'application-x-sympathy-sydata.xml']:
        try:
            os.unlink(os.path.join(folder, filename))
        except (IOError, OSError):
            pass


def update_mime_database():
    """
    Update mime type and application databases. This needs to be called after
    adding/removing desktop entries or mime types.
    """
    home = os.path.expanduser('~')
    mime_folder = os.path.join(home, '.local', 'share', 'mime')
    subprocess.run(['update-mime-database', mime_folder])
    applications_folder = os.path.join(home, '.local', 'share', 'applications')
    subprocess.run(['update-desktop-database', applications_folder])


def thread_count():
    try:
        import psutil
        try:
            return psutil.NUM_CPUS
        except AttributeError:
            return psutil.cpu_count()
    except ImportError:
        if prim.is_cygwin():
            with open('/proc/cpuinfo') as f:
                count = 0
                for line in f:
                    if cygcore.match(line):
                        count += 1
                return count

        core_logger.debug('Could not determine number of threads.')
        return 1


def limited_thread_count(limit=4):
    return max(min(thread_count(), limit), 1)


def Popen(args, **kwargs):
    stdin = kwargs.pop('stdin', None)
    stdout = kwargs.pop('stdout', None)
    stderr = kwargs.pop('stderr', None)
    close_fds = kwargs.pop('close_fds', None)
    env = kwargs.pop('env', None)

    if stdin is None:
        stdin = sys.stdin
    if stdout is None:
        stdout = sys.stdout
    if stderr is None:
        stderr = sys.stderr

    if close_fds is None:
        close_fds = prim.is_posix()

    if env:
        env = dict(env.items())
    else:
        env = os.environ

    args = [arg if isinstance(arg, str)
            else arg.decode(fs_encoding)
            for arg in args]

    return subprocess.Popen(args,
                            stdin=stdin,
                            stdout=stdout,
                            stderr=stderr,
                            close_fds=close_fds,
                            env=env,
                            **kwargs)


def open_in_new_sympathy(filename):
    return subprocess.Popen(
        [sys.executable, '-m', 'sympathy', 'gui', filename])


def Popen_no_console(*args, **kwargs):
    startupinfo = None
    if prim.is_windows():
        startupinfo = kwargs.pop('startupinfo', subprocess.STARTUPINFO())
        startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW
        startupinfo.wShowWindow = subprocess.SW_HIDE

    stdin = kwargs.pop('stdin', subprocess.PIPE)
    stdout = kwargs.pop('stdout', subprocess.PIPE)
    stderr = kwargs.pop('stderr', subprocess.PIPE)

    return Popen(*args, stdin=stdin, stdout=stdout, stderr=stderr,
                 startupinfo=startupinfo, **kwargs)


def run_filename(filename):
    if prim.is_osx():
        args = ['open', filename]
    elif prim.is_windows():
        args = ['cmd', '/c' 'start', '', filename]
    elif prim.is_posix():
        args = ['xdg-open', filename]

    return Popen_no_console(
        args,
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)


def run_editor(filename):
    if editor_api.edit_file(filename) is False:
        run_filename(filename)


if prim.is_windows():
    import pywintypes
    import win32api
    import win32con
    import win32file
    import win32job
    import win32process
    from ctypes import windll, wintypes
    import winreg
    from win32com.client import Dispatch
elif prim.is_posix():
    import fcntl


class TimeoutError(Exception):
    pass


class IFileLock(object):
    def __init__(self, file_object):
        self._file = file_object

    def aquire(self):
        raise NotImplementedError

    def release(self):
        raise NotImplementedError

    def __enter__(self):
        self.aquire()

    def __exit__(self, *args):
        self.release()


class FileLockUnix(IFileLock):
    def aquire(self):
        fcntl.fcntl(self._file.fileno(), fcntl.LOCK_EX)

    def release(self):
        fcntl.fcntl(self._file.fileno(), fcntl.LOCK_UN)


class FileLockCygwin(IFileLock):
    def aquire(self):
        core_logger.debug('File lock is not implemented for cygwin.')

    def release(self):
        core_logger.debug('File lock is not implemented for cygwin.')


class FileLockDarwin(IFileLock):
    def aquire(self):
        fcntl.flock(self._file.fileno(), fcntl.LOCK_EX)

    def release(self):
        fcntl.flock(self._file.fileno(), fcntl.LOCK_UN)


class FileLockWindows(IFileLock):
    def aquire(self):
        win32file.LockFileEx(win32file._get_osfhandle(self._file.fileno()),
                             win32con.LOCKFILE_EXCLUSIVE_LOCK, 0, -0x10000,
                             pywintypes.OVERLAPPED())

    def release(self):
        try:
            win32file.UnlockFileEx(
                win32file._get_osfhandle(self._file.fileno()),
                0, -0x10000, pywintypes.OVERLAPPED())
        except pywintypes.error as e:
            # Do not fail unlocking unlocked file.
            if e[0] == 158:
                pass
            else:
                raise


class FileLockTimeout(IFileLock):
    def __init__(self, file_object, timeout):
        self.timeout = float(timeout)
        self._file_lock = _file_lock_factory()(file_object)

    def aquire(self):
        def run_aquire():
            self._file_lock.aquire()
            with mutex:
                if done.is_set():
                    self.release()
                done.set()

        mutex = threading.Lock()
        done = threading.Event()
        thread = threading.Thread(target=run_aquire)
        thread.daemon = True
        thread.start()
        thread.join(self.timeout)
        with mutex:
            if not done.is_set():
                done.set()
                raise TimeoutError

    def release(self):
        self._file_lock.release()


class FileLock(IFileLock):
    def __init__(self, file_object, timeout=None):
        self.timeout = timeout
        if timeout is None:
            self._file_lock = _file_lock_factory()(file_object)
        else:
            self._file_lock = FileLockTimeout(file_object, timeout)

    def aquire(self):
        self._file_lock.aquire()

    def release(self):
        self._file_lock.release()


def _file_lock_factory():
    if prim.is_windows():
        return FileLockWindows
    elif prim.is_posix():
        if prim.is_osx():
            return FileLockDarwin
        if prim.is_cygwin():
            return FileLockCygwin
        return FileLockUnix
    assert(False)


class IProcessGroup(object):
    def __init__(self):
        raise NotImplementedError

    def add_pid(self, pid):
        raise NotImplementedError

    def subprocess_arguments(self):
        raise NotImplementedError


class ProcessGroupWindows(IProcessGroup):
    def __init__(self):
        hJob = win32job.CreateJobObject(None, '')
        info = win32job.QueryInformationJobObject(
            hJob, win32job.JobObjectExtendedLimitInformation)
        info['BasicLimitInformation']['LimitFlags'] = (
            win32job.JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE)
        win32job.SetInformationJobObject(
            hJob, win32job.JobObjectExtendedLimitInformation, info)
        self._hJob = hJob

    def add_pid(self, pid):
        hProcess = win32api.OpenProcess(win32con.PROCESS_SET_QUOTA |
                                        win32con.PROCESS_TERMINATE,
                                        False, pid)
        win32job.AssignProcessToJobObject(self._hJob, hProcess)
        win32api.CloseHandle(hProcess)

    def subprocess_arguments(self):
        return {'creationflags': win32process.CREATE_BREAKAWAY_FROM_JOB}


class ProcessGroupUnix(IProcessGroup):
    def __init__(self):
        os.setpgrp()

    def add_pid(self, pid):
        # Currently inherited from the parent process.
        # For more fine grained control or to cover more usecases, this
        # Would have to be refined.
        pass

    def subprocess_arguments(self):
        return {'close_fds': True}


def process_group_factory():
    if prim.is_windows():
        return ProcessGroupWindows()
    elif prim.is_posix():
        return ProcessGroupUnix()
    assert(False)


def focus_widget(widget, popup_only=False):
    """
    Brings a widget window into focus on systems where it is needed
    (currently Windows). `popup_only` == True allows to raise the window to
    the top.
    """
    if prim.is_windows():
        null_ptr = ctypes.POINTER(ctypes.c_int)()
        bg_hwnd = widget.winId()
        try:
            bg_pid = ctypes.windll.user32.GetWindowThreadProcessId(
                bg_hwnd, null_ptr)
        except ctypes.ArgumentError:
            ctypes.pythonapi.PyCObject_AsVoidPtr.restype = ctypes.c_void_p
            ctypes.pythonapi.PyCObject_AsVoidPtr.argtypes = [ctypes.py_object]
            bg_hwnd = ctypes.pythonapi.PyCObject_AsVoidPtr(bg_hwnd)
            bg_pid = ctypes.windll.user32.GetWindowThreadProcessId(
                bg_hwnd, null_ptr)

        fg_hwnd = ctypes.windll.user32.GetForegroundWindow()
        fg_pid = ctypes.windll.user32.GetWindowThreadProcessId(
            fg_hwnd, null_ptr)

        if bg_pid == 0 or fg_pid == 0:
            return

        if ctypes.windll.user32.AttachThreadInput(fg_pid, bg_pid, 1) == 0:
            return

        if ctypes.windll.user32.SetForegroundWindow(bg_hwnd) == 0:
            return

        if not popup_only:
            if ctypes.windll.user32.BringWindowToTop(fg_hwnd) == 0:
                return

        if ctypes.windll.user32.BringWindowToTop(bg_hwnd) == 0:
            return

        if ctypes.windll.user32.AttachThreadInput(fg_pid, bg_pid, 0) == 0:
            return
    elif prim.is_linux():
        widget.setWindowFlags(
            widget.windowFlags() | QtCore.Qt.WindowStaysOnTopHint)
        widget.raise_()
        widget.setWindowFlags(
            widget.windowFlags() & ~QtCore.Qt.WindowStaysOnTopHint)
        widget.show()
        return


def raise_window(widget):
    """
    Raises the window to the top.
    """
    if prim.is_windows():
        if widget.isMinimized():
            widget.showNormal()
        focus_widget(widget, True)
    elif prim.is_linux():
        if widget.isMinimized():
            widget.showNormal()
        old_pos = widget.pos()
        widget.setWindowFlags(
            widget.windowFlags() | QtCore.Qt.WindowStaysOnTopHint)
        widget.raise_()
        widget.setWindowFlags(
            widget.windowFlags() & ~QtCore.Qt.WindowStaysOnTopHint)
        widget.move(old_pos)
        widget.show()
    elif prim.is_osx():
        widget.raise_()


def set_application_id(identifier='Combine Control Systems AB.Sympathy.SympathyGUI'):
    if prim.is_windows():
        try:
            ctypes.windll.shell32.SetCurrentProcessExplicitAppUserModelID(
                identifier)
        except:
            # Only available on Windows 7 and later.
            pass


CSIDL_STARTMENU = 11
CSIDL_COMMON_STARTMENU = 22


def _path(csidl):
    buf = ctypes.create_unicode_buffer(wintypes.MAX_PATH)
    windll.shell32.SHGetFolderPathW(0, csidl, 0, 0, buf)
    return buf.value


def create_shortcut(path, target, arguments=None, working_dir=None, icon=None):
    shell = Dispatch('WScript.Shell')
    shortcut = shell.CreateShortCut(path)
    shortcut.Targetpath = target

    if working_dir:
        shortcut.WorkingDirectory = working_dir
    if arguments:
        shortcut.Arguments = arguments

    if icon:
        shortcut.IconLocation = icon
    shortcut.save()


def register_ext(ext, cls, desc, cmd, icon=None, hive=None):
    # Not using default value due to winreg only being available on win32.
    hive = hive or winreg.HKEY_CURRENT_USER
    with winreg.OpenKey(hive, r'Software\Classes') as key:
        extkey = winreg.CreateKey(key, ext)
        winreg.SetValue(extkey, '', winreg.REG_SZ, cls)
        clskey = winreg.CreateKey(key, cls)
        winreg.SetValue(clskey, '', winreg.REG_SZ, desc)
        cmdkey = winreg.CreateKey(clskey, r'shell\open\command')
        winreg.SetValue(cmdkey, '', winreg.REG_SZ, cmd)
        if icon:
            icokey = winreg.CreateKey(clskey, r'DefaultIcon')
            winreg.SetValue(icokey, '', winreg.REG_SZ, icon)


def unregister_ext(ext, cls,  hive=None):
    # Not using default value due to winreg only being available on win32.
    hive = hive or winreg.HKEY_CURRENT_USER
    with winreg.OpenKey(hive, r'Software\Classes') as key:
        paths = [ext]
        path = ['shell', 'open', 'command']

        for i in reversed(range(1, len(path))):
            paths.append('{}\\{}'.format('\\'.join(path[:i + 1]), cls))

        paths.append('{}\\DefaultIcon'.format(cls))
        paths.append(cls)

        for path in paths:
            try:
                winreg.DeleteKey(key, path)
            except OSError:
                pass


def set_shared_opengl_contexts():
    import Qt
    if Qt.__binding__ in ['PySide2', 'PyQt5']:
        Qt.QtWidgets.QApplication.setAttribute(
            Qt.QtCore.Qt.AA_ShareOpenGLContexts, True)


def set_high_dpi_unaware():
    import Qt
    if Qt.__binding__ in ['PySide2', 'PyQt5']:
        import Qt.QtWidgets
        import Qt.QtCore
        # TODO(erik): Disabling scaling, for now.
        Qt.QtWidgets.QApplication.setAttribute(
            Qt.QtCore.Qt.AA_DisableHighDpiScaling, True)
        # Qt.QtWidgets.QApplication.setAttribute(
        #     Qt.QtCore.Qt.AA_EnableHighDpiScaling, True)
        Qt.QtWidgets.QApplication.setAttribute(
            Qt.QtCore.Qt.AA_UseHighDpiPixmaps, True)
    if prim.is_windows():
        try:
            ctypes.windll.shcore.SetProcessDpiAwareness(0)
        except (AttributeError, OSError):
            # For Windows 8 and later.
            # Older windows, such as, Windows 7 doesn't have this api
            # but fails with OSError.
            pass


def flush_clipboard():
    if prim.is_windows():
        try:
            ctypes.oledll.ole32.OleFlushClipboard()
        except:
            # Extra caution to avoid failure because of clipboard
            # flushing.
            pass


def register_app(subkey, name, ver, uinst, quinst, publisher, hive=None):
    # Not using default value due to winreg only being available on win32.
    hive = hive or winreg.HKEY_CURRENT_USER
    with winreg.OpenKey(
            hive,
            r'Software\Microsoft\Windows\CurrentVersion\Uninstall') as key:
        uinkey = winreg.CreateKey(key, subkey)
        winreg.SetValueEx(uinkey, 'DisplayName', 0, winreg.REG_SZ, name)
        winreg.SetValueEx(uinkey, 'DisplayVersion', 0, winreg.REG_SZ, ver)
        winreg.SetValueEx(uinkey, 'UninstallString', 0, winreg.REG_SZ, uinst)
        winreg.SetValueEx(uinkey, 'QuietUninstallString', 0, winreg.REG_SZ,
                          quinst)
        winreg.SetValueEx(uinkey, 'Publisher', 0, winreg.REG_SZ, publisher)


def unregister_app(subkey, hive=None):
    # Not using default value due to winreg only being available on win32.
    hive = hive or winreg.HKEY_CURRENT_USER
    with winreg.OpenKey(
            hive,
            r'Software\Microsoft\Windows\CurrentVersion\Uninstall') as key:
        try:
            winreg.DeleteKey(key, subkey)
        except OSError:
            pass


def start_menu(common=False):
    loc = CSIDL_COMMON_STARTMENU if common else CSIDL_STARTMENU
    return _path(loc)


def create_start_menu_shortcuts(path, shortcuts, common=False):
    root = os.path.join(start_menu(common=common), path)
    try:
        os.makedirs(root)
    except OSError:
        pass

    for shortcut in shortcuts:
        name, target, arguments, working_dir, icon = shortcut
        fullpath = os.path.join(root, name)
        if os.path.exists(fullpath):
            os.remove(fullpath)

        create_shortcut(fullpath, target, arguments, working_dir, icon)


def delete_start_menu_shortcuts(path, common=False):
    root = os.path.join(start_menu(common=common), path)
    try:
        shutil.rmtree(root)
    except OSError:
        pass


def set_application_name(name):
    if prim.is_osx():
        try:
            # TODO(erik): check if these requirements (used to be able to
            # import Cocoa) would be resonable to add to requires.txt: pip
            # install pyobjc-framework-cocoa
            from Foundation import NSBundle
        except ImportError:
            core_logger.error(
                'Failed to set application name, please run: '
                'pip install pyobjc-framework-cocoa.')
        else:
            # Replace 'Python' with 'name' in the Mac OS menu
            bundle = NSBundle.mainBundle()
            if bundle:
                info = (bundle.localizedInfoDictionary() or
                        bundle.infoDictionary())
                if (info is not None and ('CFBundleName' not in info or
                                          info['CFBundleName'] == 'Python')):
                    # The info dictionary is empty for some reason on macOS
                    # 10.13, and perhaps lower versions, so add CFBundleName if
                    # missing.  For macOS 10.10 the dictionary is populated.
                    info['CFBundleName'] = name


def encoded_stream(stream, encoding='utf-8'):
    def norm(enc):
        return enc.lower().replace('-', '')

    if stream and norm(stream.encoding) != norm(encoding):
        out_stream = codecs.getwriter(encoding)(stream.buffer)
        out_stream.buffer = stream.buffer
        out_stream.encoding = encoding
        stream = out_stream
    return stream
