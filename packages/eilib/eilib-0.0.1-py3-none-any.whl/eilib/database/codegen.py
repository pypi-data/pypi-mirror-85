import os
from io import TextIOBase

from . import schemas
from .basic_types import BasicList
from .helpers import friendly_name_to_classname, friendly_name_to_varname, parse_custom_type


class DatabaseModulesGenerator:

    def __init__(self, db_schema: dict, out_file: TextIOBase):
        self._db_schema = db_schema
        self._out_file = out_file

    def generate(self):
        abcs = ", ".join([
            "EiDatabase",
            *(["EiDatabaseCustomType"] if self._db_schema["types"] else []),
            "EiDatabaseTable",
            "EiDatabaseTableRow",
        ])
        # Generate header
        self._out_file.writelines([
            "# Autogenerated file. Do not modify\n",
            "import typing\n\n" if self._has_any_list_field() else "",
            f"from .abstract import {abcs}\n",
        ])

        # Generate custom types
        for type_name, type_schema in self._db_schema["types"].items():
            self._generate_custom_type(type_name, type_schema)

        # Generate table rows
        for table_schema in self._db_schema["tables"]:
            self._generate_table_row(table_schema)

        # Generate tables
        for table_schema in self._db_schema["tables"]:
            self._generate_table(table_schema)

        # Generate database
        self._generate_database()

    def _type_to_str(self, type_):
        if isinstance(type_, BasicList):
            return f"typing.List[{self._type_to_str(type_.base_type)}]"
        if isinstance(type_, str):
            field_type, is_list, _ = parse_custom_type(type_)
            return f"typing.List[{self._type_to_str(field_type)}]" if is_list else field_type
        return type_.value_type.__name__

    def _has_any_list_field(self):
        # Check tables
        for table_schema in self._db_schema["tables"]:
            for field in table_schema["fields"]:
                if self._type_to_str(field["type"]).startswith("typing.List"):
                    return True
        # Check custom types
        for type_schema in self._db_schema["types"].values():
            if isinstance(type_schema, list):
                for field in type_schema:
                    if self._type_to_str(field["type"]).startswith("typing.List"):
                        return True
        return False

    def _generate_custom_type(self, type_name, type_schema: dict):
        if isinstance(type_schema, dict):
            assert isinstance(type_schema["base"], BasicList)
            field_type = self._type_to_str(type_schema["base"].base_type)
            fields = [(friendly_name_to_varname(n), field_type) for n in type_schema["names"]]
        elif isinstance(type_schema, list):
            fields = [(friendly_name_to_varname(f["name"]), self._type_to_str(f["type"]))
                      for f in type_schema]
        else:
            assert False, "Unexpected type of custom type"

        self._out_file.writelines([
            "\n\n",
            f"class {type_name}(EiDatabaseCustomType):\n",
            "\n",
            "    __slots__ = (\n",
            *[f'        "{n}",\n' for n, _ in fields],
            "    )\n",
            "\n",
            "    def __init__(self):\n",
            *[f'        self.{n}: {t} = None\n' for n, t in fields],
            "        super().__init__()\n",
        ])

    def _generate_table_row(self, table_schema: dict):
        class_name = friendly_name_to_classname(table_schema['name'], remove_plural=True)
        db_class_name = friendly_name_to_classname(self._db_schema['name']) + "Database"
        fields = [(friendly_name_to_varname(f["name"]), self._type_to_str(f["type"]))
                  for f in table_schema["fields"]]

        self._out_file.writelines([
            "\n\n",
            f"class {class_name}(EiDatabaseTableRow):\n",
            "\n",
            "    __slots__ = (\n",
            *[f'        "{n}",\n' for n, _ in fields],
            "    )\n",
            "\n",
            "    def __init__(self):\n",
            *[f'        self.{n}: {t} = None\n' for n, t in fields],
            "        super().__init__()\n",
            "\n",
            "    @property\n",
            "    def _db_type(self):\n",
            f"        return {db_class_name}\n",
        ])

    def _generate_table(self, table_schema: dict):
        class_name = friendly_name_to_classname(table_schema['name'])
        row_class_name = friendly_name_to_classname(table_schema['name'], remove_plural=True)
        self._out_file.writelines([
            "\n\n",
            f"class {class_name}(EiDatabaseTable[{row_class_name}]):\n",
            "\n",
            f"    _row_type = {row_class_name}\n",
        ])

    def _generate_database(self):
        db_class_name = friendly_name_to_classname(self._db_schema['name']) + "Database"
        fields = [(friendly_name_to_varname(t["name"]), friendly_name_to_classname(t["name"]))
                  for t in self._db_schema["tables"]]
        custom_types = f"{', '.join(self._db_schema['types'].keys())}"

        self._out_file.writelines([
            "\n\n",
            f"class {db_class_name}(EiDatabase):\n",
            "\n",
            "    __slots__ = (\n",
            *[f'        "{n}",\n' for n, _ in fields],
            "    )\n",
            (f"    _custom_types = {{t.__name__: t for t in ({custom_types},)}}\n"
             if custom_types else ""),
            "\n",
            "    def __init__(self):\n",
            *[f'        self.{n} = {t}()\n' for n, t in fields],
            "        super().__init__()\n",
        ])


def main():
    dirname = os.path.dirname(__file__)
    for schema in schemas.SCHEMAS_LIST:
        filename = f"{friendly_name_to_varname(schema['name'])}.py"
        with open(os.path.join(dirname, filename), "w") as f:
            DatabaseModulesGenerator(schema, f).generate()


if __name__ == "__main__":
    main()
