# coding: utf-8

"""
    Stencila Hub API

    ## Authentication  Many endpoints in the Stencila Hub API require an authentication token. These tokens carry many privileges, so be sure to keep them secure. Do not place your tokens in publicly accessible areas such as client-side code. The API is only served over HTTPS to avoid exposing tokens and other data on the network.  To obtain a token, [`POST /api/tokens`](#operations-tokens-tokens_create) with either a `username` and `password` pair, or an [OpenID Connect](https://openid.net/connect/) token. Then use the token in the `Authorization` header of subsequent requests with the prefix `Token` e.g.      curl -H \"Authorization: Token 48866b1e38a2e9db0baada2140b2327937f4a3636dd5f2dfd8c212341c88d34\" https://hub.stenci.la/api/projects/  Alternatively, you can use `Basic` authentication with the token used as the username and no password. This can be more convenient when using command line tools such as [cURL](https://curl.haxx.se/) e.g.      curl -u 48866b1e38a2e9db0baada2140b2327937f4a3636dd5f2dfd8c212341c88d34: https://hub.stenci.la/api/projects/  Or, the less ubiquitous, but more accessible [httpie](https://httpie.org/):      http --auth 48866b1e38a2e9db0baada2140b2327937f4a3636dd5f2dfd8c212341c88d34: https://hub.stenci.la/api/projects/  In both examples above, the trailing colon is not required but avoids being asked for a password.  ## Versioning  The Stencila Hub is released using semantic versioning. The current version is available from the [`GET /api/status`](/api/status) endpoint. Please see the [Github release page](https://github.com/stencila/hub/releases) and the [changelog](https://github.com/stencila/hub/blob/master/CHANGELOG.md) for details on each release. We currently do not provide versioning of the API but plan to do so soon (probably by using a `Accept: application/vnd.stencila.hub+json;version=1.0` request header). If you are using, or interested in using, the API please contact us and we may be able to expedite this.   # noqa: E501

    The version of the OpenAPI document: v1
    Contact: hello@stenci.la
    Generated by: https://openapi-generator.tech
"""


import inspect
import pprint
import re  # noqa: F401
import six

from stencila.hub.configuration import Configuration


class Worker(object):
    """NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    """
    Attributes:
      openapi_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    openapi_types = {
        'id': 'int',
        'active': 'bool',
        'created': 'datetime',
        'started': 'datetime',
        'updated': 'datetime',
        'finished': 'datetime',
        'hostname': 'str',
        'utcoffset': 'int',
        'pid': 'int',
        'freq': 'float',
        'software': 'str',
        'os': 'str',
        'details': 'object',
        'signature': 'str',
        'queues': 'list[int]'
    }

    attribute_map = {
        'id': 'id',
        'active': 'active',
        'created': 'created',
        'started': 'started',
        'updated': 'updated',
        'finished': 'finished',
        'hostname': 'hostname',
        'utcoffset': 'utcoffset',
        'pid': 'pid',
        'freq': 'freq',
        'software': 'software',
        'os': 'os',
        'details': 'details',
        'signature': 'signature',
        'queues': 'queues'
    }

    def __init__(self, id=None, active=None, created=None, started=None, updated=None, finished=None, hostname=None, utcoffset=None, pid=None, freq=None, software=None, os=None, details=None, signature=None, queues=None, local_vars_configuration=None):  # noqa: E501
        """Worker - a model defined in OpenAPI"""  # noqa: E501
        if local_vars_configuration is None:
            local_vars_configuration = Configuration()
        self.local_vars_configuration = local_vars_configuration

        self._id = None
        self._active = None
        self._created = None
        self._started = None
        self._updated = None
        self._finished = None
        self._hostname = None
        self._utcoffset = None
        self._pid = None
        self._freq = None
        self._software = None
        self._os = None
        self._details = None
        self._signature = None
        self._queues = None
        self.discriminator = None

        if id is not None:
            self.id = id
        if active is not None:
            self.active = active
        if created is not None:
            self.created = created
        self.started = started
        self.updated = updated
        self.finished = finished
        self.hostname = hostname
        self.utcoffset = utcoffset
        self.pid = pid
        self.freq = freq
        self.software = software
        self.os = os
        self.details = details
        self.signature = signature
        self.queues = queues

    @property
    def id(self):
        """Gets the id of this Worker.  # noqa: E501


        :return: The id of this Worker.  # noqa: E501
        :rtype: int
        """
        return self._id

    @id.setter
    def id(self, id):
        """Sets the id of this Worker.


        :param id: The id of this Worker.  # noqa: E501
        :type id: int
        """

        self._id = id

    @property
    def active(self):
        """Gets the active of this Worker.  # noqa: E501


        :return: The active of this Worker.  # noqa: E501
        :rtype: bool
        """
        return self._active

    @active.setter
    def active(self, active):
        """Sets the active of this Worker.


        :param active: The active of this Worker.  # noqa: E501
        :type active: bool
        """

        self._active = active

    @property
    def created(self):
        """Gets the created of this Worker.  # noqa: E501

        The time that the worker started (time of the first event for the worker).  # noqa: E501

        :return: The created of this Worker.  # noqa: E501
        :rtype: datetime
        """
        return self._created

    @created.setter
    def created(self, created):
        """Sets the created of this Worker.

        The time that the worker started (time of the first event for the worker).  # noqa: E501

        :param created: The created of this Worker.  # noqa: E501
        :type created: datetime
        """

        self._created = created

    @property
    def started(self):
        """Gets the started of this Worker.  # noqa: E501

        The time that the worker started (only recorded on a 'worker-online' event).  # noqa: E501

        :return: The started of this Worker.  # noqa: E501
        :rtype: datetime
        """
        return self._started

    @started.setter
    def started(self, started):
        """Sets the started of this Worker.

        The time that the worker started (only recorded on a 'worker-online' event).  # noqa: E501

        :param started: The started of this Worker.  # noqa: E501
        :type started: datetime
        """

        self._started = started

    @property
    def updated(self):
        """Gets the updated of this Worker.  # noqa: E501

        The time that the last heatbeat was received for the worker.  # noqa: E501

        :return: The updated of this Worker.  # noqa: E501
        :rtype: datetime
        """
        return self._updated

    @updated.setter
    def updated(self, updated):
        """Sets the updated of this Worker.

        The time that the last heatbeat was received for the worker.  # noqa: E501

        :param updated: The updated of this Worker.  # noqa: E501
        :type updated: datetime
        """

        self._updated = updated

    @property
    def finished(self):
        """Gets the finished of this Worker.  # noqa: E501

        The time that the worker finished (only recorded on a 'worker-offline' event)  # noqa: E501

        :return: The finished of this Worker.  # noqa: E501
        :rtype: datetime
        """
        return self._finished

    @finished.setter
    def finished(self, finished):
        """Sets the finished of this Worker.

        The time that the worker finished (only recorded on a 'worker-offline' event)  # noqa: E501

        :param finished: The finished of this Worker.  # noqa: E501
        :type finished: datetime
        """

        self._finished = finished

    @property
    def hostname(self):
        """Gets the hostname of this Worker.  # noqa: E501

        The `hostname` of the worker.  # noqa: E501

        :return: The hostname of this Worker.  # noqa: E501
        :rtype: str
        """
        return self._hostname

    @hostname.setter
    def hostname(self, hostname):
        """Sets the hostname of this Worker.

        The `hostname` of the worker.  # noqa: E501

        :param hostname: The hostname of this Worker.  # noqa: E501
        :type hostname: str
        """
        if self.local_vars_configuration.client_side_validation and hostname is None:  # noqa: E501
            raise ValueError("Invalid value for `hostname`, must not be `None`")  # noqa: E501
        if (self.local_vars_configuration.client_side_validation and
                hostname is not None and len(hostname) > 512):
            raise ValueError("Invalid value for `hostname`, length must be less than or equal to `512`")  # noqa: E501
        if (self.local_vars_configuration.client_side_validation and
                hostname is not None and len(hostname) < 1):
            raise ValueError("Invalid value for `hostname`, length must be greater than or equal to `1`")  # noqa: E501

        self._hostname = hostname

    @property
    def utcoffset(self):
        """Gets the utcoffset of this Worker.  # noqa: E501

        The `utcoffset` of the worker.  # noqa: E501

        :return: The utcoffset of this Worker.  # noqa: E501
        :rtype: int
        """
        return self._utcoffset

    @utcoffset.setter
    def utcoffset(self, utcoffset):
        """Sets the utcoffset of this Worker.

        The `utcoffset` of the worker.  # noqa: E501

        :param utcoffset: The utcoffset of this Worker.  # noqa: E501
        :type utcoffset: int
        """

        self._utcoffset = utcoffset

    @property
    def pid(self):
        """Gets the pid of this Worker.  # noqa: E501

        The `pid` of the worker.  # noqa: E501

        :return: The pid of this Worker.  # noqa: E501
        :rtype: int
        """
        return self._pid

    @pid.setter
    def pid(self, pid):
        """Sets the pid of this Worker.

        The `pid` of the worker.  # noqa: E501

        :param pid: The pid of this Worker.  # noqa: E501
        :type pid: int
        """

        self._pid = pid

    @property
    def freq(self):
        """Gets the freq of this Worker.  # noqa: E501

        The worker's heatbeat frequency (in seconds)  # noqa: E501

        :return: The freq of this Worker.  # noqa: E501
        :rtype: float
        """
        return self._freq

    @freq.setter
    def freq(self, freq):
        """Sets the freq of this Worker.

        The worker's heatbeat frequency (in seconds)  # noqa: E501

        :param freq: The freq of this Worker.  # noqa: E501
        :type freq: float
        """

        self._freq = freq

    @property
    def software(self):
        """Gets the software of this Worker.  # noqa: E501

        The name and version of the worker's software.  # noqa: E501

        :return: The software of this Worker.  # noqa: E501
        :rtype: str
        """
        return self._software

    @software.setter
    def software(self, software):
        """Sets the software of this Worker.

        The name and version of the worker's software.  # noqa: E501

        :param software: The software of this Worker.  # noqa: E501
        :type software: str
        """
        if (self.local_vars_configuration.client_side_validation and
                software is not None and len(software) > 256):
            raise ValueError("Invalid value for `software`, length must be less than or equal to `256`")  # noqa: E501

        self._software = software

    @property
    def os(self):
        """Gets the os of this Worker.  # noqa: E501

        Operating system that the worker is running on.  # noqa: E501

        :return: The os of this Worker.  # noqa: E501
        :rtype: str
        """
        return self._os

    @os.setter
    def os(self, os):
        """Sets the os of this Worker.

        Operating system that the worker is running on.  # noqa: E501

        :param os: The os of this Worker.  # noqa: E501
        :type os: str
        """
        if (self.local_vars_configuration.client_side_validation and
                os is not None and len(os) > 64):
            raise ValueError("Invalid value for `os`, length must be less than or equal to `64`")  # noqa: E501

        self._os = os

    @property
    def details(self):
        """Gets the details of this Worker.  # noqa: E501

        Details about the worker including queues and statsSee https://docs.celeryproject.org/en/stable/userguide/workers.html#statistics  # noqa: E501

        :return: The details of this Worker.  # noqa: E501
        :rtype: object
        """
        return self._details

    @details.setter
    def details(self, details):
        """Sets the details of this Worker.

        Details about the worker including queues and statsSee https://docs.celeryproject.org/en/stable/userguide/workers.html#statistics  # noqa: E501

        :param details: The details of this Worker.  # noqa: E501
        :type details: object
        """

        self._details = details

    @property
    def signature(self):
        """Gets the signature of this Worker.  # noqa: E501

        The signature of the worker used to identify it. It is possible, but unlikely, that two or more active workers have the same signature.  # noqa: E501

        :return: The signature of this Worker.  # noqa: E501
        :rtype: str
        """
        return self._signature

    @signature.setter
    def signature(self, signature):
        """Sets the signature of this Worker.

        The signature of the worker used to identify it. It is possible, but unlikely, that two or more active workers have the same signature.  # noqa: E501

        :param signature: The signature of this Worker.  # noqa: E501
        :type signature: str
        """
        if (self.local_vars_configuration.client_side_validation and
                signature is not None and len(signature) > 512):
            raise ValueError("Invalid value for `signature`, length must be less than or equal to `512`")  # noqa: E501

        self._signature = signature

    @property
    def queues(self):
        """Gets the queues of this Worker.  # noqa: E501

        The queues that this worker is listening to.  # noqa: E501

        :return: The queues of this Worker.  # noqa: E501
        :rtype: list[int]
        """
        return self._queues

    @queues.setter
    def queues(self, queues):
        """Sets the queues of this Worker.

        The queues that this worker is listening to.  # noqa: E501

        :param queues: The queues of this Worker.  # noqa: E501
        :type queues: list[int]
        """
        if self.local_vars_configuration.client_side_validation and queues is None:  # noqa: E501
            raise ValueError("Invalid value for `queues`, must not be `None`")  # noqa: E501

        self._queues = queues

    def to_dict(self, serialize=False):
        """Returns the model properties as a dict"""
        result = {}

        def convert(x):
            if hasattr(x, "to_dict"):
                args = inspect.getargspec(x.to_dict).args
                if len(args) == 1:
                    return x.to_dict()
                else:
                    return x.to_dict(serialize)
            else:
                return x

        for attr, _ in six.iteritems(self.openapi_types):
            value = getattr(self, attr)
            attr = self.attribute_map.get(attr, attr) if serialize else attr
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: convert(x),
                    value
                ))
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], convert(item[1])),
                    value.items()
                ))
            else:
                result[attr] = convert(value)

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, Worker):
            return False

        return self.to_dict() == other.to_dict()

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        if not isinstance(other, Worker):
            return True

        return self.to_dict() != other.to_dict()
