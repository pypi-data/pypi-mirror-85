# coding: utf-8

"""
    Marketing API v.1.0

    IMPORTANT: This swagger links to Criteo production environment. Any test applied here will thus impact real campaigns.  # noqa: E501

    The version of the OpenAPI document: v.1.0
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from criteo_marketing.api_client import ApiClient
from criteo_marketing.exceptions import (
    ApiTypeError,
    ApiValueError
)


class SellersApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def create_budgets(self, authorization, seller_budgets, **kwargs):  # noqa: E501
        """Creates a budget for a seller/list of sellers.  # noqa: E501

        <b>Seller name</b>: can be retrieved from the /sellers/ endpoint. This value is case insensitive.<br /><b>Amount</b>: in your currency. Set it to \"null\" or leave empty to create an uncapped budget (with no limit).<br /><h4>Response</h4><p>              The budget's start date will be set to:<br />              • today: in case no budget is currently set for this seller<br />              • tomorrow: in case your seller already has a budget running, ending at midnight. Note that start dates are UTC+00:00 based.<br />              The budget will remain active until being completely consumed or stopped.<br /></p><h4>Validation rules</h4><p>              Budgets cannot <b>overlap</b> with each other for a specific seller.<br /></p><h4>Functional cases</h4><p>              When a seller's budget is totally consumed, display delivery will automatically stop for this specific seller.<br />              If budget needs to be updated, by: adding fund, reducing a budget amount or stopping it, refer to the “update budget” endpoint.<br /></p>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_budgets(authorization, seller_budgets, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str authorization: JWT Bearer Token (required)
        :param SellerBudgetsCreateMessage seller_budgets: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SellerBudgetsMessage
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_budgets_with_http_info(authorization, seller_budgets, **kwargs)  # noqa: E501

    def create_budgets_with_http_info(self, authorization, seller_budgets, **kwargs):  # noqa: E501
        """Creates a budget for a seller/list of sellers.  # noqa: E501

        <b>Seller name</b>: can be retrieved from the /sellers/ endpoint. This value is case insensitive.<br /><b>Amount</b>: in your currency. Set it to \"null\" or leave empty to create an uncapped budget (with no limit).<br /><h4>Response</h4><p>              The budget's start date will be set to:<br />              • today: in case no budget is currently set for this seller<br />              • tomorrow: in case your seller already has a budget running, ending at midnight. Note that start dates are UTC+00:00 based.<br />              The budget will remain active until being completely consumed or stopped.<br /></p><h4>Validation rules</h4><p>              Budgets cannot <b>overlap</b> with each other for a specific seller.<br /></p><h4>Functional cases</h4><p>              When a seller's budget is totally consumed, display delivery will automatically stop for this specific seller.<br />              If budget needs to be updated, by: adding fund, reducing a budget amount or stopping it, refer to the “update budget” endpoint.<br /></p>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_budgets_with_http_info(authorization, seller_budgets, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str authorization: JWT Bearer Token (required)
        :param SellerBudgetsCreateMessage seller_budgets: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SellerBudgetsMessage, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['authorization', 'seller_budgets']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_budgets" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'authorization' is set
        if ('authorization' not in local_var_params or
                local_var_params['authorization'] is None):
            raise ApiValueError("Missing the required parameter `authorization` when calling `create_budgets`")  # noqa: E501
        # verify the required parameter 'seller_budgets' is set
        if ('seller_budgets' not in local_var_params or
                local_var_params['seller_budgets'] is None):
            raise ApiValueError("Missing the required parameter `seller_budgets` when calling `create_budgets`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'authorization' in local_var_params:
            header_params['Authorization'] = local_var_params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'seller_budgets' in local_var_params:
            body_params = local_var_params['seller_budgets']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json', 'application/xml', 'text/xml', 'text/html'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded', 'text/html'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/v1/sellers/budgets', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SellerBudgetsMessage',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get(self, authorization, **kwargs):  # noqa: E501
        """Gets sellers details.  # noqa: E501

        Returns a list of sellers with all their details.<br />  By default, this list will contain all active sellers that have been on-boarded onto the Criteo Reseller Program.<br />  Note that (in the situation where you would have multiple Criteo Reseller Program campaigns running at the same time) campaign filter can be applied to restrict the response to one or multiple campaign ids.<br /><h4>Functional cases</h4><p>  Only currently running and future seller budgets will be retrieved. Past sellers' budgets can be retrieved from the statistics endpoint.<br />  Seller's status has 2 possible values - Active or Inactive - which corresponds to:<br />  • <b>Active</b>: Seller in a running campaign, with a bid (CPC) and a budget &gt; 0<br />  • <b>Inactive</b>: Seller with a budget consumed or that you explicitly stopped.<br /></p>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get(authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str authorization: JWT Bearer Token (required)
        :param str campaign_ids: Optional. One or more campaign ids, E.g., 78, 12932, 45236. If any of the requested campaign ids are not Criteo Reseller Program or are not liked to advertisers in the user's portfolio, the call will fail.
        :param bool only_active_sellers: Optional. Filters by seller status, allowing to only display active sellers or not. Default value is false.
        :param bool only_sellers_with_products_in_catalog: Optional. Only return sellers that have currently products in the catalog. Default value is false.
        :param bool only_active_budgets: Optional. Will return only active budget for each seller. Default value is false
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[SellerMessage]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_with_http_info(authorization, **kwargs)  # noqa: E501

    def get_with_http_info(self, authorization, **kwargs):  # noqa: E501
        """Gets sellers details.  # noqa: E501

        Returns a list of sellers with all their details.<br />  By default, this list will contain all active sellers that have been on-boarded onto the Criteo Reseller Program.<br />  Note that (in the situation where you would have multiple Criteo Reseller Program campaigns running at the same time) campaign filter can be applied to restrict the response to one or multiple campaign ids.<br /><h4>Functional cases</h4><p>  Only currently running and future seller budgets will be retrieved. Past sellers' budgets can be retrieved from the statistics endpoint.<br />  Seller's status has 2 possible values - Active or Inactive - which corresponds to:<br />  • <b>Active</b>: Seller in a running campaign, with a bid (CPC) and a budget &gt; 0<br />  • <b>Inactive</b>: Seller with a budget consumed or that you explicitly stopped.<br /></p>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_with_http_info(authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str authorization: JWT Bearer Token (required)
        :param str campaign_ids: Optional. One or more campaign ids, E.g., 78, 12932, 45236. If any of the requested campaign ids are not Criteo Reseller Program or are not liked to advertisers in the user's portfolio, the call will fail.
        :param bool only_active_sellers: Optional. Filters by seller status, allowing to only display active sellers or not. Default value is false.
        :param bool only_sellers_with_products_in_catalog: Optional. Only return sellers that have currently products in the catalog. Default value is false.
        :param bool only_active_budgets: Optional. Will return only active budget for each seller. Default value is false
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[SellerMessage], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['authorization', 'campaign_ids', 'only_active_sellers', 'only_sellers_with_products_in_catalog', 'only_active_budgets']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'authorization' is set
        if ('authorization' not in local_var_params or
                local_var_params['authorization'] is None):
            raise ApiValueError("Missing the required parameter `authorization` when calling `get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'campaign_ids' in local_var_params:
            query_params.append(('campaignIds', local_var_params['campaign_ids']))  # noqa: E501
        if 'only_active_sellers' in local_var_params:
            query_params.append(('onlyActiveSellers', local_var_params['only_active_sellers']))  # noqa: E501
        if 'only_sellers_with_products_in_catalog' in local_var_params:
            query_params.append(('onlySellersWithProductsInCatalog', local_var_params['only_sellers_with_products_in_catalog']))  # noqa: E501
        if 'only_active_budgets' in local_var_params:
            query_params.append(('onlyActiveBudgets', local_var_params['only_active_budgets']))  # noqa: E501

        header_params = {}
        if 'authorization' in local_var_params:
            header_params['Authorization'] = local_var_params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json', 'application/xml', 'text/xml', 'text/html'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/v1/sellers', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[SellerMessage]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_campaigns(self, authorization, **kwargs):  # noqa: E501
        """Gets campaigns  # noqa: E501

        Get the list of campaigns with the specified filters.  If a campaign is requested but is missing from current user's portfolio, it will not be included in the list.  If neither campaign ids nor advertisers ids are provided, then the user's portfolio will be used.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_campaigns(authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str authorization: JWT Bearer Token (required)
        :param str campaign_ids: Optional. One or more campaign ids, E.g. 78, 12932, 45236. If any of the requested campaign ids are not Criteo Reseller Program or are not liked to advertisers in the user's portfolio, the call will fail.
        :param str advertiser_ids: Optional. One or more advertiser ids, E.g. 78, 12932, 45236. If the requested advertiser ids are not part of the user's portfolio, the call will fail.
        :param str status: Optional. Status of the campaign. By default, all campaigns are returned, regardless of their status.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[MarketplaceCampaignMessage]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_campaigns_with_http_info(authorization, **kwargs)  # noqa: E501

    def get_campaigns_with_http_info(self, authorization, **kwargs):  # noqa: E501
        """Gets campaigns  # noqa: E501

        Get the list of campaigns with the specified filters.  If a campaign is requested but is missing from current user's portfolio, it will not be included in the list.  If neither campaign ids nor advertisers ids are provided, then the user's portfolio will be used.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_campaigns_with_http_info(authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str authorization: JWT Bearer Token (required)
        :param str campaign_ids: Optional. One or more campaign ids, E.g. 78, 12932, 45236. If any of the requested campaign ids are not Criteo Reseller Program or are not liked to advertisers in the user's portfolio, the call will fail.
        :param str advertiser_ids: Optional. One or more advertiser ids, E.g. 78, 12932, 45236. If the requested advertiser ids are not part of the user's portfolio, the call will fail.
        :param str status: Optional. Status of the campaign. By default, all campaigns are returned, regardless of their status.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[MarketplaceCampaignMessage], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['authorization', 'campaign_ids', 'advertiser_ids', 'status']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_campaigns" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'authorization' is set
        if ('authorization' not in local_var_params or
                local_var_params['authorization'] is None):
            raise ApiValueError("Missing the required parameter `authorization` when calling `get_campaigns`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'campaign_ids' in local_var_params:
            query_params.append(('campaignIds', local_var_params['campaign_ids']))  # noqa: E501
        if 'advertiser_ids' in local_var_params:
            query_params.append(('advertiserIds', local_var_params['advertiser_ids']))  # noqa: E501
        if 'status' in local_var_params:
            query_params.append(('status', local_var_params['status']))  # noqa: E501

        header_params = {}
        if 'authorization' in local_var_params:
            header_params['Authorization'] = local_var_params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json', 'application/xml', 'text/xml', 'text/html'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/v1/sellers/campaigns', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[MarketplaceCampaignMessage]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_stats(self, authorization, stats_query, **kwargs):  # noqa: E501
        """Generates a statistics report  # noqa: E501

        <b>AdvertiserIds</b>: Optional. The list of advertiser ids, comma-separated. Advertisers not in your portfolio will be skipped. If not present, all the advertisers in the portfolio will be used.<br /><b>StartDate, EndDate</b>: Start date (beginning of day) and end date (end of day) to be used for the report generation. Format to use: yyyy-MM-dd (e.g. 2017-10-30).<br /><b>Dimensions</b>: The dimensions to be used in the report. Between one and three. Possible values: CampaignId, AdvertiserId, Seller, Day, Week, Month, Year.<br /><b>Metrics</b>: The metrics to be used in the report. Possible values: Clicks, AdvertiserCost, Displays.<br /><b>Format</b>: The file format of the generated report. Possible values: Csv, Excel, Xml, Json.<br /><b>Currency</b>: Optional. The currency to be used in the report. Three-letter capitals. For a list of possible values, please see the full documentation. If not set, the user's preference setting will be used.<br /><b>Timezone</b>: Optional. Timezone to be used in the report. Possible values: GMT, PST, JST. If not set, the user's preference setting will be used.<br /><h4>Validation rules</h4>              StartDate and EndDate are mandatory.<br />              StartDate should come before, or be equal to EndDate.<br />              The requested dimensions must be in a supported combination.<br />              At least one metric must be provided.<br />              All metrics must be supported.<br />              The selected advertisers must have at least one campaign.<br />              Seller dimension is mandatory.<br />  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_stats(authorization, stats_query, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str authorization: JWT Bearer Token (required)
        :param StatsQueryMessage stats_query: The report query details (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_stats_with_http_info(authorization, stats_query, **kwargs)  # noqa: E501

    def get_stats_with_http_info(self, authorization, stats_query, **kwargs):  # noqa: E501
        """Generates a statistics report  # noqa: E501

        <b>AdvertiserIds</b>: Optional. The list of advertiser ids, comma-separated. Advertisers not in your portfolio will be skipped. If not present, all the advertisers in the portfolio will be used.<br /><b>StartDate, EndDate</b>: Start date (beginning of day) and end date (end of day) to be used for the report generation. Format to use: yyyy-MM-dd (e.g. 2017-10-30).<br /><b>Dimensions</b>: The dimensions to be used in the report. Between one and three. Possible values: CampaignId, AdvertiserId, Seller, Day, Week, Month, Year.<br /><b>Metrics</b>: The metrics to be used in the report. Possible values: Clicks, AdvertiserCost, Displays.<br /><b>Format</b>: The file format of the generated report. Possible values: Csv, Excel, Xml, Json.<br /><b>Currency</b>: Optional. The currency to be used in the report. Three-letter capitals. For a list of possible values, please see the full documentation. If not set, the user's preference setting will be used.<br /><b>Timezone</b>: Optional. Timezone to be used in the report. Possible values: GMT, PST, JST. If not set, the user's preference setting will be used.<br /><h4>Validation rules</h4>              StartDate and EndDate are mandatory.<br />              StartDate should come before, or be equal to EndDate.<br />              The requested dimensions must be in a supported combination.<br />              At least one metric must be provided.<br />              All metrics must be supported.<br />              The selected advertisers must have at least one campaign.<br />              Seller dimension is mandatory.<br />  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_stats_with_http_info(authorization, stats_query, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str authorization: JWT Bearer Token (required)
        :param StatsQueryMessage stats_query: The report query details (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['authorization', 'stats_query']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_stats" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'authorization' is set
        if ('authorization' not in local_var_params or
                local_var_params['authorization'] is None):
            raise ApiValueError("Missing the required parameter `authorization` when calling `get_stats`")  # noqa: E501
        # verify the required parameter 'stats_query' is set
        if ('stats_query' not in local_var_params or
                local_var_params['stats_query'] is None):
            raise ApiValueError("Missing the required parameter `stats_query` when calling `get_stats`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'authorization' in local_var_params:
            header_params['Authorization'] = local_var_params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'stats_query' in local_var_params:
            body_params = local_var_params['stats_query']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded', 'text/html'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/v1/sellers/stats', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_bids(self, authorization, seller_bids, **kwargs):  # noqa: E501
        """Set or update a bid for a seller/list of sellers.  # noqa: E501

        <b>Seller name</b>: can be retrieved from the /sellers/ endpoint. This value is case insensitive.              <h4>Functional cases</h4><p>              In case one of the bid values cannot be updated, the whole batch will be dropped.<br /></p>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_bids(authorization, seller_bids, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str authorization: JWT Bearer Token (required)
        :param SellerBidsMessage seller_bids: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SellerBidsMessage
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_bids_with_http_info(authorization, seller_bids, **kwargs)  # noqa: E501

    def update_bids_with_http_info(self, authorization, seller_bids, **kwargs):  # noqa: E501
        """Set or update a bid for a seller/list of sellers.  # noqa: E501

        <b>Seller name</b>: can be retrieved from the /sellers/ endpoint. This value is case insensitive.              <h4>Functional cases</h4><p>              In case one of the bid values cannot be updated, the whole batch will be dropped.<br /></p>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_bids_with_http_info(authorization, seller_bids, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str authorization: JWT Bearer Token (required)
        :param SellerBidsMessage seller_bids: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SellerBidsMessage, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['authorization', 'seller_bids']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_bids" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'authorization' is set
        if ('authorization' not in local_var_params or
                local_var_params['authorization'] is None):
            raise ApiValueError("Missing the required parameter `authorization` when calling `update_bids`")  # noqa: E501
        # verify the required parameter 'seller_bids' is set
        if ('seller_bids' not in local_var_params or
                local_var_params['seller_bids'] is None):
            raise ApiValueError("Missing the required parameter `seller_bids` when calling `update_bids`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'authorization' in local_var_params:
            header_params['Authorization'] = local_var_params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'seller_bids' in local_var_params:
            body_params = local_var_params['seller_bids']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json', 'application/xml', 'text/xml', 'text/html'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded', 'text/html'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/v1/sellers/bids', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SellerBidsMessage',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_budgets(self, authorization, seller_budgets, **kwargs):  # noqa: E501
        """Updates a budget for a seller/list of sellers.  # noqa: E501

        <b>Amount</b>: Optional. Uses the advertiser's currency. Set it to \"null\" or leave empty to create an uncapped budget (with no limit).<br /><b>Status</b>: Optional. Budget's status, possible values are: [\"Inactive\",\"Active\"]. If set to null or undefined, status does not change.              <h4>Validation rules</h4><p>              Budgets cannot <b>overlap</b> with each other for a specific seller.<br />              Budget's <b>amount</b> can be decreased if it did not start yet.<br />              Budget's <b>status</b> can only be changed from \"Active\" to \"Inactive\", if budget already started.<br /><b>Inactive</b> budgets cannot be updated.              </p><h4>Functional cases</h4><h5>Increase budget amount</h5><p>              Budget can only be increased if its end date is not reached.<br />              Amount value must include the amount that has been already spent.<br />              Example: if you want to add 50€ to a 100€ budget, you should update the amount to 150€, regardless of the amount already spent.<br />              Or, alternatively, you can set it to \"null\" or leave empty to change the budget to uncapped.<br /></p><h5>Stop budget consumption</h5><p>              Setting a currently running budget’s status to Inactive, result in:<br />              • Setting its end date to today (at 23:59:59, according to UTC+00:00)<br />              • Stopping its consumption instantly<br /></p><h5>Decrease budget amount</h5><p>              In order to decrease the amount of a currently running budget, you have to:<br />              • Stop budget consumption (making the currently running budget to end at 23:59:59, according to UTC+00:00)<br />              • Create a new budget with a dedicated amount. (that will start the following day, according to UTC+00:00)<br /></p>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_budgets(authorization, seller_budgets, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str authorization: JWT Bearer Token (required)
        :param SellerBudgetsUpdateMessage seller_budgets: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SellerBudgetsMessage
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_budgets_with_http_info(authorization, seller_budgets, **kwargs)  # noqa: E501

    def update_budgets_with_http_info(self, authorization, seller_budgets, **kwargs):  # noqa: E501
        """Updates a budget for a seller/list of sellers.  # noqa: E501

        <b>Amount</b>: Optional. Uses the advertiser's currency. Set it to \"null\" or leave empty to create an uncapped budget (with no limit).<br /><b>Status</b>: Optional. Budget's status, possible values are: [\"Inactive\",\"Active\"]. If set to null or undefined, status does not change.              <h4>Validation rules</h4><p>              Budgets cannot <b>overlap</b> with each other for a specific seller.<br />              Budget's <b>amount</b> can be decreased if it did not start yet.<br />              Budget's <b>status</b> can only be changed from \"Active\" to \"Inactive\", if budget already started.<br /><b>Inactive</b> budgets cannot be updated.              </p><h4>Functional cases</h4><h5>Increase budget amount</h5><p>              Budget can only be increased if its end date is not reached.<br />              Amount value must include the amount that has been already spent.<br />              Example: if you want to add 50€ to a 100€ budget, you should update the amount to 150€, regardless of the amount already spent.<br />              Or, alternatively, you can set it to \"null\" or leave empty to change the budget to uncapped.<br /></p><h5>Stop budget consumption</h5><p>              Setting a currently running budget’s status to Inactive, result in:<br />              • Setting its end date to today (at 23:59:59, according to UTC+00:00)<br />              • Stopping its consumption instantly<br /></p><h5>Decrease budget amount</h5><p>              In order to decrease the amount of a currently running budget, you have to:<br />              • Stop budget consumption (making the currently running budget to end at 23:59:59, according to UTC+00:00)<br />              • Create a new budget with a dedicated amount. (that will start the following day, according to UTC+00:00)<br /></p>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_budgets_with_http_info(authorization, seller_budgets, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str authorization: JWT Bearer Token (required)
        :param SellerBudgetsUpdateMessage seller_budgets: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SellerBudgetsMessage, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['authorization', 'seller_budgets']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_budgets" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'authorization' is set
        if ('authorization' not in local_var_params or
                local_var_params['authorization'] is None):
            raise ApiValueError("Missing the required parameter `authorization` when calling `update_budgets`")  # noqa: E501
        # verify the required parameter 'seller_budgets' is set
        if ('seller_budgets' not in local_var_params or
                local_var_params['seller_budgets'] is None):
            raise ApiValueError("Missing the required parameter `seller_budgets` when calling `update_budgets`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'authorization' in local_var_params:
            header_params['Authorization'] = local_var_params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'seller_budgets' in local_var_params:
            body_params = local_var_params['seller_budgets']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json', 'application/xml', 'text/xml', 'text/html'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded', 'text/html'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/v1/sellers/budgets', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SellerBudgetsMessage',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)
