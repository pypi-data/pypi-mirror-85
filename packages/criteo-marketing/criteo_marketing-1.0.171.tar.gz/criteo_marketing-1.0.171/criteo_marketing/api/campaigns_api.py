# coding: utf-8

"""
    Marketing API v.1.0

    IMPORTANT: This swagger links to Criteo production environment. Any test applied here will thus impact real campaigns.  # noqa: E501

    The version of the OpenAPI document: v.1.0
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from criteo_marketing.api_client import ApiClient
from criteo_marketing.exceptions import (
    ApiTypeError,
    ApiValueError
)


class CampaignsApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def get_bids(self, authorization, **kwargs):  # noqa: E501
        """Gets a the bids for campaigns and their categories  # noqa: E501

        Get the campaigns' bids, as well as the bids of their categories  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bids(authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str authorization: JWT Bearer Token (required)
        :param str campaign_ids: Optional. The ids of the campaigns we want to get the bids on. If not specified, advertiserIds will be used.
        :param str advertiser_ids: Optional. The ids of the advertisers' campaigns we want to get the bids on. If campaignIds not specified, and neither is advertiserIds, all the advertisers in the user's portfolio are used.
        :param str category_hash_codes: Optional. Filters only specified categories. By default no filtering is applied.
        :param str bid_type: Optional. Filters by bid type. By default no filtering is applied.
        :param str campaign_status: Optional. Filters by campaign status. By default no filtering is applied.
        :param bool pending_changes: Optional. Filters only pending changes or settled ones. By default no filtering is applied.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[CampaignBidMessage]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_bids_with_http_info(authorization, **kwargs)  # noqa: E501

    def get_bids_with_http_info(self, authorization, **kwargs):  # noqa: E501
        """Gets a the bids for campaigns and their categories  # noqa: E501

        Get the campaigns' bids, as well as the bids of their categories  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bids_with_http_info(authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str authorization: JWT Bearer Token (required)
        :param str campaign_ids: Optional. The ids of the campaigns we want to get the bids on. If not specified, advertiserIds will be used.
        :param str advertiser_ids: Optional. The ids of the advertisers' campaigns we want to get the bids on. If campaignIds not specified, and neither is advertiserIds, all the advertisers in the user's portfolio are used.
        :param str category_hash_codes: Optional. Filters only specified categories. By default no filtering is applied.
        :param str bid_type: Optional. Filters by bid type. By default no filtering is applied.
        :param str campaign_status: Optional. Filters by campaign status. By default no filtering is applied.
        :param bool pending_changes: Optional. Filters only pending changes or settled ones. By default no filtering is applied.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[CampaignBidMessage], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['authorization', 'campaign_ids', 'advertiser_ids', 'category_hash_codes', 'bid_type', 'campaign_status', 'pending_changes']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bids" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'authorization' is set
        if ('authorization' not in local_var_params or
                local_var_params['authorization'] is None):
            raise ApiValueError("Missing the required parameter `authorization` when calling `get_bids`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'campaign_ids' in local_var_params:
            query_params.append(('campaignIds', local_var_params['campaign_ids']))  # noqa: E501
        if 'advertiser_ids' in local_var_params:
            query_params.append(('advertiserIds', local_var_params['advertiser_ids']))  # noqa: E501
        if 'category_hash_codes' in local_var_params:
            query_params.append(('categoryHashCodes', local_var_params['category_hash_codes']))  # noqa: E501
        if 'bid_type' in local_var_params:
            query_params.append(('bidType', local_var_params['bid_type']))  # noqa: E501
        if 'campaign_status' in local_var_params:
            query_params.append(('campaignStatus', local_var_params['campaign_status']))  # noqa: E501
        if 'pending_changes' in local_var_params:
            query_params.append(('pendingChanges', local_var_params['pending_changes']))  # noqa: E501

        header_params = {}
        if 'authorization' in local_var_params:
            header_params['Authorization'] = local_var_params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json', 'application/xml', 'text/xml', 'text/html'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/v1/campaigns/bids', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[CampaignBidMessage]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_campaign(self, campaign_id, authorization, **kwargs):  # noqa: E501
        """Gets a specific campaign  # noqa: E501

        Get a specific campaign  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_campaign(campaign_id, authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int campaign_id: Mandatory. The id of the campaign to return. (required)
        :param str authorization: JWT Bearer Token (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CampaignMessage
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_campaign_with_http_info(campaign_id, authorization, **kwargs)  # noqa: E501

    def get_campaign_with_http_info(self, campaign_id, authorization, **kwargs):  # noqa: E501
        """Gets a specific campaign  # noqa: E501

        Get a specific campaign  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_campaign_with_http_info(campaign_id, authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int campaign_id: Mandatory. The id of the campaign to return. (required)
        :param str authorization: JWT Bearer Token (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CampaignMessage, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['campaign_id', 'authorization']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_campaign" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'campaign_id' is set
        if ('campaign_id' not in local_var_params or
                local_var_params['campaign_id'] is None):
            raise ApiValueError("Missing the required parameter `campaign_id` when calling `get_campaign`")  # noqa: E501
        # verify the required parameter 'authorization' is set
        if ('authorization' not in local_var_params or
                local_var_params['authorization'] is None):
            raise ApiValueError("Missing the required parameter `authorization` when calling `get_campaign`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'campaign_id' in local_var_params:
            path_params['campaignId'] = local_var_params['campaign_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'authorization' in local_var_params:
            header_params['Authorization'] = local_var_params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json', 'application/xml', 'text/xml', 'text/html'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/v1/campaigns/{campaignId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CampaignMessage',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_campaigns(self, authorization, **kwargs):  # noqa: E501
        """Gets campaigns  # noqa: E501

        Get the list of campaigns with the specified filters.  If a campaign is requested but is missing from current user's portfolio, it will not be included in the list.  If neither campaign ids nor advertisers ids are provided, then the user's portfolio will be used.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_campaigns(authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str authorization: JWT Bearer Token (required)
        :param str campaign_ids: Optional. One or more campaign ids, E.g., 78, 12932, 45236. If the campaign ids requested are not linked to advertisers in the user's portfolio, they will be skipped.
        :param str advertiser_ids: Optional. One or more advertiser ids, E.g., 78, 12932, 45236. If the advertiser ids requested are not part of the user's portfolio, they will be skipped.
        :param str campaign_status: Optional. Filters by campaign status. By default no filtering is applied.
        :param str bid_type: Optional. Filters by campaign bid type. By default, no filtering is applied.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[CampaignMessage]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_campaigns_with_http_info(authorization, **kwargs)  # noqa: E501

    def get_campaigns_with_http_info(self, authorization, **kwargs):  # noqa: E501
        """Gets campaigns  # noqa: E501

        Get the list of campaigns with the specified filters.  If a campaign is requested but is missing from current user's portfolio, it will not be included in the list.  If neither campaign ids nor advertisers ids are provided, then the user's portfolio will be used.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_campaigns_with_http_info(authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str authorization: JWT Bearer Token (required)
        :param str campaign_ids: Optional. One or more campaign ids, E.g., 78, 12932, 45236. If the campaign ids requested are not linked to advertisers in the user's portfolio, they will be skipped.
        :param str advertiser_ids: Optional. One or more advertiser ids, E.g., 78, 12932, 45236. If the advertiser ids requested are not part of the user's portfolio, they will be skipped.
        :param str campaign_status: Optional. Filters by campaign status. By default no filtering is applied.
        :param str bid_type: Optional. Filters by campaign bid type. By default, no filtering is applied.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[CampaignMessage], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['authorization', 'campaign_ids', 'advertiser_ids', 'campaign_status', 'bid_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_campaigns" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'authorization' is set
        if ('authorization' not in local_var_params or
                local_var_params['authorization'] is None):
            raise ApiValueError("Missing the required parameter `authorization` when calling `get_campaigns`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'campaign_ids' in local_var_params:
            query_params.append(('campaignIds', local_var_params['campaign_ids']))  # noqa: E501
        if 'advertiser_ids' in local_var_params:
            query_params.append(('advertiserIds', local_var_params['advertiser_ids']))  # noqa: E501
        if 'campaign_status' in local_var_params:
            query_params.append(('campaignStatus', local_var_params['campaign_status']))  # noqa: E501
        if 'bid_type' in local_var_params:
            query_params.append(('bidType', local_var_params['bid_type']))  # noqa: E501

        header_params = {}
        if 'authorization' in local_var_params:
            header_params['Authorization'] = local_var_params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json', 'application/xml', 'text/xml', 'text/html'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/v1/campaigns', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[CampaignMessage]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_categories(self, campaign_id, authorization, **kwargs):  # noqa: E501
        """Gets categories  # noqa: E501

        Get the list of categories linked to the requested campaign.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_categories(campaign_id, authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int campaign_id: Mandatory. The id of the campaign the categories are linked to. (required)
        :param str authorization: JWT Bearer Token (required)
        :param bool enabled_only: Optional. Returns only categories you can bid on. Defaults to false.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CategoryMessage
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_categories_with_http_info(campaign_id, authorization, **kwargs)  # noqa: E501

    def get_categories_with_http_info(self, campaign_id, authorization, **kwargs):  # noqa: E501
        """Gets categories  # noqa: E501

        Get the list of categories linked to the requested campaign.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_categories_with_http_info(campaign_id, authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int campaign_id: Mandatory. The id of the campaign the categories are linked to. (required)
        :param str authorization: JWT Bearer Token (required)
        :param bool enabled_only: Optional. Returns only categories you can bid on. Defaults to false.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CategoryMessage, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['campaign_id', 'authorization', 'enabled_only']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_categories" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'campaign_id' is set
        if ('campaign_id' not in local_var_params or
                local_var_params['campaign_id'] is None):
            raise ApiValueError("Missing the required parameter `campaign_id` when calling `get_categories`")  # noqa: E501
        # verify the required parameter 'authorization' is set
        if ('authorization' not in local_var_params or
                local_var_params['authorization'] is None):
            raise ApiValueError("Missing the required parameter `authorization` when calling `get_categories`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'campaign_id' in local_var_params:
            path_params['campaignId'] = local_var_params['campaign_id']  # noqa: E501

        query_params = []
        if 'enabled_only' in local_var_params:
            query_params.append(('enabledOnly', local_var_params['enabled_only']))  # noqa: E501

        header_params = {}
        if 'authorization' in local_var_params:
            header_params['Authorization'] = local_var_params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json', 'application/xml', 'text/xml', 'text/html'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/v1/campaigns/{campaignId}/categories', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CategoryMessage',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_category(self, campaign_id, category_hash_code, authorization, **kwargs):  # noqa: E501
        """Gets a specific category  # noqa: E501

        Get a specific category linked to the requested campaign.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_category(campaign_id, category_hash_code, authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int campaign_id: Mandatory. The id of the campaign the categories are linked to. (required)
        :param int category_hash_code: Mandatory. The id of the category to return. (required)
        :param str authorization: JWT Bearer Token (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CategoryMessage
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_category_with_http_info(campaign_id, category_hash_code, authorization, **kwargs)  # noqa: E501

    def get_category_with_http_info(self, campaign_id, category_hash_code, authorization, **kwargs):  # noqa: E501
        """Gets a specific category  # noqa: E501

        Get a specific category linked to the requested campaign.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_category_with_http_info(campaign_id, category_hash_code, authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int campaign_id: Mandatory. The id of the campaign the categories are linked to. (required)
        :param int category_hash_code: Mandatory. The id of the category to return. (required)
        :param str authorization: JWT Bearer Token (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CategoryMessage, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['campaign_id', 'category_hash_code', 'authorization']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_category" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'campaign_id' is set
        if ('campaign_id' not in local_var_params or
                local_var_params['campaign_id'] is None):
            raise ApiValueError("Missing the required parameter `campaign_id` when calling `get_category`")  # noqa: E501
        # verify the required parameter 'category_hash_code' is set
        if ('category_hash_code' not in local_var_params or
                local_var_params['category_hash_code'] is None):
            raise ApiValueError("Missing the required parameter `category_hash_code` when calling `get_category`")  # noqa: E501
        # verify the required parameter 'authorization' is set
        if ('authorization' not in local_var_params or
                local_var_params['authorization'] is None):
            raise ApiValueError("Missing the required parameter `authorization` when calling `get_category`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'campaign_id' in local_var_params:
            path_params['campaignId'] = local_var_params['campaign_id']  # noqa: E501
        if 'category_hash_code' in local_var_params:
            path_params['categoryHashCode'] = local_var_params['category_hash_code']  # noqa: E501

        query_params = []

        header_params = {}
        if 'authorization' in local_var_params:
            header_params['Authorization'] = local_var_params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json', 'application/xml', 'text/xml', 'text/html'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/v1/campaigns/{campaignId}/categories/{categoryHashCode}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CategoryMessage',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_bids(self, authorization, bid_changes, **kwargs):  # noqa: E501
        """Update bids for campaigns and their categories  # noqa: E501

        If a campaign bid is updated, all (if any) category bids for this campaign will be updated with the new value if they are initially equal to the campaign bid.  If the category bid is not wanted to be cascaded to the categories with the same bid value, new change bids must be added in the request for the categories where the value should be kept (with the initial value).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_bids(authorization, bid_changes, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str authorization: JWT Bearer Token (required)
        :param list[CampaignBidChangeRequest] bid_changes: Specifies the list of bid changes to be applied. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[CampaignMessage]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_bids_with_http_info(authorization, bid_changes, **kwargs)  # noqa: E501

    def update_bids_with_http_info(self, authorization, bid_changes, **kwargs):  # noqa: E501
        """Update bids for campaigns and their categories  # noqa: E501

        If a campaign bid is updated, all (if any) category bids for this campaign will be updated with the new value if they are initially equal to the campaign bid.  If the category bid is not wanted to be cascaded to the categories with the same bid value, new change bids must be added in the request for the categories where the value should be kept (with the initial value).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_bids_with_http_info(authorization, bid_changes, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str authorization: JWT Bearer Token (required)
        :param list[CampaignBidChangeRequest] bid_changes: Specifies the list of bid changes to be applied. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[CampaignMessage], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['authorization', 'bid_changes']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_bids" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'authorization' is set
        if ('authorization' not in local_var_params or
                local_var_params['authorization'] is None):
            raise ApiValueError("Missing the required parameter `authorization` when calling `update_bids`")  # noqa: E501
        # verify the required parameter 'bid_changes' is set
        if ('bid_changes' not in local_var_params or
                local_var_params['bid_changes'] is None):
            raise ApiValueError("Missing the required parameter `bid_changes` when calling `update_bids`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'authorization' in local_var_params:
            header_params['Authorization'] = local_var_params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'bid_changes' in local_var_params:
            body_params = local_var_params['bid_changes']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json', 'application/xml', 'text/xml', 'text/html'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded', 'text/html'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/v1/campaigns/bids', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[CampaignMessage]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)
