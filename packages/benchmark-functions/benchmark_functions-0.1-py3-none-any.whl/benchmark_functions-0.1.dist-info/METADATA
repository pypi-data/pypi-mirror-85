Metadata-Version: 2.1
Name: benchmark-functions
Version: 0.1
Summary: A benchmark functions collection wrote in Python 3, suited for assessing the performances of optimisation problems on deterministic functions.
Home-page: https://gitlab.com/luca.baronti/python_benchmark_functions
Author: Luca Baronti
Author-email: lbaronti@gmail.com
License: GNUv3
Download-URL: https://pypi.org/project/benchmark_functions/
Keywords: Optimisation,Optimization,Benchmark,Functions
Platform: UNKNOWN
Classifier: Development Status :: 3 - Alpha
Classifier: Intended Audience :: Education
Classifier: Intended Audience :: Science/Research
Classifier: Topic :: Scientific/Engineering :: Mathematics
Classifier: License :: OSI Approved :: GNU General Public License v3 (GPLv3)
Classifier: Programming Language :: Python :: 3
Description-Content-Type: text/markdown
Requires-Dist: numpy

# Benchmark Functions: a Python Collection

A benchmark functions collection wrote in Python 3, suited for assessing the performances of optimisation problems on deterministic functions. Most functions here implemented can be created in an arbitrary number of dimensions. Suggested boundaries, as well the values of known minima/maxima, are also provided. Finally, every function can be visualised with an interactive widget.

## Usage
To use a function from the collection it is sufficient to instantiate the relative class from the library:
```python
import benchmark_functions as bf

func = bf.Schwefel(n_dimensions=4)
```
calling directly the instantiated function on a point will provide the function's value:
```python
point = [25, -34.6, -112.231, 242]
func(point) # results in -129.38197657025287
```
Most functions impelmented can be instantiated with an arbitrary number of dimensions. This can be set with a  *n_dimensions* optional parameter. If the numer of dimensions are not specified a default value (generally $N=2$) will be used.
Some functions require other specific parameters (e.g. Ackley), these can be set in the constructor, otherwise default values will be taken.
Some functions are only defined for 2 dimensions (e.g. Easom) in these cases no *n_dimensions* parameter is accepted.

Normally, these functions are designed for a minimisation problem, so they are designed accordingly.
An optional flag **opposite** can be passed in any function constructor.
If set to *True* the value of the function will be the opposite at each call, as well as the **optimum** value.
This is useful to use a maximisation algorithm on these functions.

A set of convenience functions are also set in the class, namely:

-  **getName** the name of the function
-  **getMinima**/**getMaxima**[^1] a list of tuples (*point*, *value*) with the coordinate and value of the global minima/maxima. If any value is unkown, a *None* value will be present instead.
-  **getMinimum**/**getMaximum**[^1] a single tuple (*point*, *value*) with the coordinate and value of the global minimum/maximum. If any value is unkown, a *None* value will be present instead.
-  **getSuggestedBounds** returns a tuple of two elements (*LB*, *UB*) each one is a list of *n_dimensions* elements, representing the suggested search boundary of the function.
- **show** plot the function in an interactive graphic widget. Read the relative section below for more information on this feature.

As an example, the following code:
```python
print(func.getSuggestedBounds())
```
will produce
```
([-500.0, -500.0, -500.0, -500.0], [500.0, 500.0, 500.0, 500.0])
```
for the Schwefel function.

[^1]: generally a function global minimum/maximum can change with the number of dimensions. For this reason some **minima**/**maxima** values may be missing or inaccurate. If you find a better global optimum please open an issue about that with the coordinates and I'll update the library.
### Visualise a function
Using the *show* function will plot the benchmark function in an interactive widget.
This can be done only if the *n_dimensions* is lower than 3. The resulting plot is either a 3D surface (when *n_dimensions=2*) or a simple 2D graph plot (*n_dimensions=1*). If the function is defined in 2 dimensions, it is also possible to plot it as an heatmap setting the function parameter *asHeatMap=True* as follows:
```python
func.show(asHeatMap=True)
```

Note: whilst importing and using the library require nothing more than the tandard *math* python library, in order to visualise the functions the libraries *mlp_toolkits*, *numpy*, and *matplotlib* are also required.

## List of Available Functions

For a list of available functions please refer to the [project homepage](https://gitlab.com/luca.baronti/python_benchmark_functions).


## Author and License

This library is developed and mantained by Luca Baronti (**gmail** address: *lbaronti*) and released under [GPL v3 license](LICENSE).



