<?xml version='1.0'?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc linkmailto="no" ?>
<?rfc editing="no" ?>
<?rfc comments="yes" ?>
<?rfc inline="yes"?>
<?rfc rfcedstyle="yes"?>
<?rfc-ext allow-markup-in-artwork="yes" ?>
<?rfc-ext include-index="no" ?>
<!--<?rfc strict="no"?> -->

<rfc category="std"
     ipr="trust200902"
     docName="draft-ietf-netconf-keystore-02" >
    <front>
        <title>Keystore Model</title>
        <author initials="K.W." surname="Watsen" fullname="Kent Watsen">
            <organization>Juniper Networks</organization>
            <address>
                <email>kwatsen@juniper.net</email>
            </address>
        </author>
        <date/>
        <area>Operations</area>
        <workgroup>NETCONF Working Group</workgroup>
        <abstract>
            <t>This document defines a YANG data module for a system-level keystore
            mechanism, that might be used to hold onto private keys and certificates
            that are trusted by the system advertising support for this module.</t>
        </abstract>
        <note title="Editorial Note (To be removed by RFC Editor)">
          <t>This draft contains many placeholder values that need to be replaced
          with finalized values at the time of publication.  This note summarizes
          all of the substitutions that are needed.  No other RFC Editor 
          instructions are specified elsewhere in this document.</t>

          <t>Artwork in this document contains shorthand references to drafts in 
          progress.  Please apply the following replacements:
            <list  style="symbols">
              <t><spanx style="verb">VVVV</spanx> --&gt; the assigned RFC value for this draft</t>
            </list>
          </t>
          <t>Artwork in this document contains placeholder values for the date of publication of this
          draft.  Please apply the following replacement:
            <list  style="symbols">
              <t><spanx style="verb">2017-06-13</spanx> --&gt; the publication date of this draft</t>
            </list>
          </t>
          <t>The following Appendix section is to be removed prior to publication:
            <list  style="symbols">
              <t>Appendix A.  Change Log</t>
            </list>
          </t>
        </note>
    </front>
    <middle>
      <section title="Introduction">

        <t>This document defines a YANG <xref target="RFC6020"/> data module for
        a system-level keystore mechanism, which can be used to hold onto 
        private keys and certificates that are trusted by the system advertising
        support for this module.</t>

        <t>This module provides a centralized location for security sensitive
        data, so that the data can be then referenced by other modules.
        There are two types of data that are maintained by this module:
          <list style="symbols">
            <t>Private keys, and any associated public certificates.</t>
            <t>Sets of trusted certificates.</t>
          </list>
        </t>

        <t>This document extends special consideration for systems that have 
        Trusted Protection Modules (TPMs).  These systems are unique in
        that the TPM must be directed to generate new private keys (it is
        not possible to load a private key into a TPM) and it is not 
        possible to backup/restore the TPM's private keys as configuration.</t>

        <t>It is not required that a system has an operating system level
        keystore utility to implement this module.</t>


        <section title="Requirements Language">
          <t>The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL",
          "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY",
          and "OPTIONAL" in this document are to be interpreted as
          described in RFC 2119 <xref target="RFC2119"/>.</t>
        </section>

        <section title="Tree Diagram Notation" anchor="tree-diagrams">
          <t>A simplified graphical representation of the data models
          is used in this document.  The meaning of the symbols in
          these diagrams is as follows:
            <list style="symbols">
              <t>Brackets "[" and "]" enclose list keys.</t>
              <t>Braces "{" and "}" enclose feature names, and indicate
              that the named feature must be present for the subtree
              to be present.</t>
              <t>Abbreviations before data node names: "rw" means
              configuration (read-write) and "ro" state data 
              (read-only).</t>
              <t>Symbols after data node names: "?" means an optional
              node, "!" means a presence container, and "*" denotes a
              list and leaf-list.</t>
              <t>Parentheses enclose choice and case nodes, and case
              nodes are also marked with a colon (":").</t>
              <t>Ellipsis ("...") stands for contents of subtrees that
              are not shown.</t>
            </list>
          </t>
        </section>
      </section>

      <section title="The Keystore Model" anchor="keystore-model">
        <t>The keystore module defined in this section provides a configurable
        object having the following characteristics:
          <list style="symbols">
            <t>A semi-configurable list of private keys, each with one or more associated
            certificates.  Private keys MUST be either preinstalled (e.g., a key associated
            to an IDevID <xref target="Std-802.1AR-2009"/> certificate),
            be generated by request, or be loaded by request.  Each private key is MAY have
            associated certificates, either preinstalled or configured after creation.</t>
            <t>A configurable list of lists of trust anchor certificates.  This enables 
            the server to have use-case specific trust anchors.  For instance, one list of 
            trust anchors might be used to authenticate management connections (e.g.,
            client certificate-based authentication for NETCONF or RESTCONF connections),
            and a different list of trust anchors might be used for when connecting to a
            specific Internet-based service (e.g., a zero touch bootstrap server).</t>
            <t>An RPC to generate a certificate signing request for an existing private
            key, a passed subject, and an optional attributes.  The signed certificate
            returned from an external certificate authority (CA) can be later set using
            a standard configuration change request (e.g., &lt;edit-config&gt;).</t>
            <t>An RPC to request the server to generate a new private key using the
            specified algorithm and key length.</t>
            <t>An RPC to request the server to load a new private key.</t>
          </list>
        </t>
        <section title="Overview">
          <t>The keystore module has the following tree diagram.  Please see <xref target="tree-diagrams"/> for information on how to interpret this diagram.
            <figure>
              <artwork><![CDATA[
module: ietf-keystore
    +--rw keystore
       +--rw keys
       |  +--rw key* [name]
       |  |  +--rw name                                    string
       |  |  +--rw algorithm-identifier                    identityref
       |  |  +--rw private-key                             union
       |  |  +--ro public-key                              binary
       |  |  +--rw certificates
       |  |  |  +--rw certificate* [name]
       |  |  |     +--rw name     string
       |  |  |     +--rw value?   binary
       |  |  +---x generate-certificate-signing-request
       |  |     +---w input
       |  |     |  +---w subject       binary
       |  |     |  +---w attributes?   binary
       |  |     +--ro output
       |  |        +--ro certificate-signing-request    binary
       |  +---x generate-private-key
       |     +---w input
       |        +---w name         string
       |        +---w algorithm    identityref
       +--rw trusted-certificates* [name]
       |  +--rw name                   string
       |  +--rw description?           string
       |  +--rw trusted-certificate* [name]
       |     +--rw name           string
       |     +--rw certificate?   binary
       +--rw trusted-host-keys* [name]
          +--rw name                string
          +--rw description?        string
          +--rw trusted-host-key* [name]
             +--rw name        string
             +--rw host-key    binary

  notifications:
    +---n certificate-expiration
       +--ro certificate        instance-identifier
       +--ro expiration-date    yang:date-and-time
]]></artwork>
            </figure>
          </t>
        </section>

        <section title="Example Usage">
          <t>The following example illustrates what a fully configured keystore object
          might look like.  The private-key shown below is consistent with the 
          generate-private-key and generate-certificate-signing-request examples above.
          This example also assumes that the resulting CA-signed certificate has been
          configured back onto the server.  Lastly, this example shows that three
          lists of trusted certificates having been configured.</t>
          <t>
            <figure>
              <artwork><![CDATA[
<keystore xmlns="urn:ietf:params:xml:ns:yang:ietf-keystore">

  <!-- private keys and associated certificates -->
  <keys>
    <key>
      <name>ex-rsa-key</name>
      <algorithm-identifier>rsa1024</algorithm-identifier>
      <private-key>Base64-encoded RSA Private Key</private-key>
      <public-key>Base64-encoded RSA Public Key</public-key>
      <certificates>
        <certificate>
          <name>ex-rsa-cert</name>
          <value>Base64-encoded PKCS#7</value>
        </certificate>
      </certificates>
    </key>
 
    <key>
      <name>tls-ec-key</name>
      <algorithm-identifier>secp256r1</algorithm-identifier>
      <private-key>Base64-encoded EC Private Key</private-key>
      <public-key>Base64-encoded EC Public Key</public-key>
      <certificates>
        <certificate>
          <name>tls-ec-cert</name>
          <value>Base64-encoded PKCS#7</value>
        </certificate>
      </certificates>
    </key>

    <key>
      <name>tpm-protected-key</name>
      <algorithm-identifier>rsa2048</algorithm-identifier>
      <private-key>Base64-encoded RSA Private Key</private-key>
      <public-key>Base64-encoded RSA Public Key</public-key>
      <certificates>
        <certificate>
          <name>builtin-idevid-cert</name>
          <value>Base64-encoded PKCS#7</value>
        </certificate>
        <certificate>
          <name>my-ldevid-cert</name>
          <value>Base64-encoded PKCS#7</value>
        </certificate>
      </certificates>
    </key>
  </keys>

  <!-- trusted netconf/restconf client certificates -->
  <trusted-certificates>
    <name>explicitly-trusted-client-certs</name>
    <description>
      Specific client authentication certificates for explicitly
      trusted clients.  These are needed for client certificates
      that are not signed by a trusted CA.
    </description>
    <trusted-certificate>
      <name>George Jetson</name>
      <certificate>Base64-encoded X.509v3</certificate>
    </trusted-certificate>
  </trusted-certificates>

  <trusted-certificates>
    <name>explicitly-trusted-server-certs</name>
    <description>
      Specific server authentication certificates for explicitly
      trusted servers.  These are needed for server certificates
      that are not signed by a trusted CA.
    </description>
    <trusted-certificate>
      <name>Fred Flintstone</name>
      <certificate>Base64-encoded X.509v3</certificate>
    </trusted-certificate>
  </trusted-certificates>

  <!-- trust anchors (CA certs) for authenticating clients -->
  <trusted-certificates>
    <name>deployment-specific-ca-certs</name>
    <description>
      Trust anchors (i.e. CA certs) that are used to authenticate 
      client connections.  Clients are authenticated if their
      certificate has a chain of trust to one of these configured
      CA certificates.
    </description>
    <trusted-certificate>
      <name>ca.example.com</name>
      <certificate>Base64-encoded X.509v3</certificate>
    </trusted-certificate>
  </trusted-certificates>

  <!-- trust anchors for random HTTPS servers on Internet -->
  <trusted-certificates>
    <name>common-ca-certs</name>
    <description>
      Trusted certificates to authenticate common HTTPS servers.
      These certificates are similar to those that might be
      shipped with a web browser.
    </description>
    <trusted-certificate>
      <name>ex-certificate-authority</name>
      <certificate>Base64-encoded X.509v3</certificate>
    </trusted-certificate>
  </trusted-certificates>

  <!-- trusted SSH host keys -->
  <trusted-host-keys>
    <name>explicitly-trusted-ssh-host-keys</name>
    <description>
      Trusted SSH host keys used to authenticate SSH servers.
      These host keys would be analogous to those stored in
      a known_hosts file in OpenSSH.
    </description>
    <trusted-host-key>
      <name>corp-fw1</name>
      <host-key>Base64-encoded OneAsymmetricKey</host-key>
    </trusted-host-key>
  </trusted-host-keys>

</keystore>
]]></artwork>
            </figure>
          </t>

          <t>The following example illustrates the "generate-certificate-signing-request"
          action in use with the NETCONF protocol.</t>
          <t>
            <figure>
              <artwork><![CDATA[
REQUEST
-------

  <rpc message-id="101"
    xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <action xmlns="urn:ietf:params:xml:ns:yang:1">
      <keystore 
        xmlns="urn:ietf:params:xml:ns:yang:ietf-keystore">
        <keys>
          <key>
            <name>ex-key-sect571r1</name>
            <generate-certificate-signing-request>
              <subject>
               cztvaWRoc2RmZ2tqaHNkZmdramRzZnZzZGtmam5idnNvO2R
               manZvO3NkZmJpdmhzZGZpbHVidjtvc2lkZmhidml1bHNlmO
               Z2aXNiZGZpYmhzZG87ZmJvO3NkZ25iO29pLmR6Zgo=
              </subject>
              <attributes>
               bwtakWRoc2RmZ2tqaHNkZmdramRzZnZzZGtmam5idnNvut4
               arnZvO3NkZmJpdmhzZGZpbHVidjtvc2lkZmhidml1bHNkYm
               Z2aXNiZGZpYmhzZG87ZmJvO3NkZ25iO29pLmC6Rhp=
              </attributes>
            </generate-certificate-signing-request>
          </key>
        </keys>
      </keystore>
    </action>
  </rpc>


RESPONSE
--------

  <rpc-reply message-id="101"
     xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
     <certificate-signing-request
       xmlns="urn:ietf:params:xml:ns:yang:ietf-keystore">
       LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUNrekNDQWZ5Z
       0F3SUJBZ0lKQUpRT2t3bGpNK2pjTUEwR0NTcUdTSWIzRFFFQkJRVU
       FNRFF4Q3pBSkJnTlYKQkFZVEFsVlRNUkF3RGdZRFZRUUtFd2RsZUd
       GdGNHeGxNUk13RVFZRFZRUURFd3BEVWt3Z1NYTnpkV1Z5TUI0WApE
       diR1V4RXpBUkJnTlZCQU1UQ2tOU1RDQkpjM04xWlhJd2daOHdEUVl
       KS29aSWh2Y04KQVFFQkJRQURnWTBBTUlHSkFvR0JBTXVvZmFPNEV3
       El1QWMrQ1RsTkNmc0d6cEw1Um5ydXZsOFRIcUJTdGZQY3N0Zk1KT1
       FaNzlnNlNWVldsMldzaHE1bUViCkJNNitGNzdjbTAvU25FcFE0TnV
       bXBDT2YKQWdNQkFBR2pnYXd3Z2Frd0hRWURWUjBPQkJZRUZKY1o2W
       URiR0lPNDB4ajlPb3JtREdsRUNCVTFNR1FHQTFVZApJd1JkTUZ1QU
       ZKY1o2WURiR0lPNDB4ajlPb3JtREdsRUNCVTFvVGlrTmpBME1Rc3d
       mMKTUE0R0ExVWREd0VCL3dRRUF3SUNCREFTQmdOVkhSTUJBZjhFQ0
       RBR0FRSC9BZ0VBTUEwR0NTcUdTSWIzRFFFQgpCUVVBQTRHQkFMMmx
       rWmFGNWcyaGR6MVNhZnZPbnBneHA4eG00SHRhbStadHpLazFlS3Bx
       TXp4YXJCbFpDSHlLCklVbC9GVzRtV1RQS1VDeEtFTE40NEY2Zmk2d
       c4d0tSSElkYW1WL0pGTmlQS0VXSTF4K1I1aDZmazcrQzQ1QXg1RWV
       SWHgzZjdVM2xZTgotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCg==
     </certificate-signing-request>
  </rpc-reply>

]]></artwork>
            </figure>
          </t>

          <t>The following example illustrates the "generate-private-key" action
          in use with the RESTCONF protocol and JSON encoding.</t>
          <t>
            <figure>
              <artwork><![CDATA[
REQUEST
-------

  ['\' line wrapping added for formatting only]
  
  POST https://example.com/restconf/data/ietf-keystore:keystore/\
  keys/generate-private-key HTTP/1.1
  HOST: example.com
  Content-Type: application/yang.operation+json
  
  {
    "ietf-keystore:input" : {
      "name" : "ex-key-sect571r1",
      "algorithm" : "sect571r1"
    }
  }


RESPONSE
--------

  HTTP/1.1 204 No Content
  Date: Mon, 31 Oct 2015 11:01:00 GMT
  Server: example-server

]]></artwork>
            </figure>
          </t>

          <t>The following example illustrates a "certificate-expiration"
          notification in XML.</t>
          <t>
            <figure>
              <artwork><![CDATA[
['\' line wrapping added for formatting only]

<notification
  xmlns="urn:ietf:params:xml:ns:netconf:notification:1.0">
  <eventTime>2016-07-08T00:01:00Z</eventTime>
  <certificate-expiration 
    xmlns="urn:ietf:params:xml:ns:yang:ietf-keystore">
    <certificate>/ks:keystore/ks:private-keys/ks:private-key\
    /ks:certificate-chains/ks:certificate-chain/ks:certificate[3]\
    </certificate>
    <expiration-date>2016-08-08T14:18:53-05:00</expiration-date>
  </certificate-expiration>
</notification>
]]></artwork>
            </figure>
          </t>

        </section>

        <section title="YANG Module" anchor="keystore-yang-module">
          <t>This YANG module makes extensive use of data types defined in
          <xref target="RFC5280"/> and <xref target="RFC5958"/>.</t>
          <t>
            <figure>
              <artwork><![CDATA[

<CODE BEGINS> file "ietf-keystore@2017-06-13.yang"

module ietf-keystore {
  yang-version 1.1;

  namespace "urn:ietf:params:xml:ns:yang:ietf-keystore";
  prefix "ks";

  import ietf-yang-types {
    prefix yang;
    reference 
      "RFC 6991: Common YANG Data Types";
  }

  import ietf-netconf-acm {
    prefix nacm;
    reference
      "RFC 6536: Network Configuration Protocol (NETCONF) Access
       Control Model";
  }

  organization
   "IETF NETCONF (Network Configuration) Working Group";

  contact
   "WG Web:   <http://tools.ietf.org/wg/netconf/>
    WG List:  <mailto:netconf@ietf.org>

    Author:   Kent Watsen
              <mailto:kwatsen@juniper.net>";


  description
   "This module defines a keystore to centralize management
    of security credentials.

    Copyright (c) 2014 IETF Trust and the persons identified
    as authors of the code. All rights reserved.

    Redistribution and use in source and binary forms, with
    or without modification, is permitted pursuant to, and
    subject to the license terms contained in, the Simplified
    BSD License set forth in Section 4.c of the IETF Trust's
    Legal Provisions Relating to IETF Documents
    (http://trustee.ietf.org/license-info).

    This version of this YANG module is part of RFC VVVV; see
    the RFC itself for full legal notices.";

  revision "2017-06-13" {
    description
     "Initial version";
    reference
     "RFC VVVV: NETCONF Server and RESTCONF Server Configuration 
                Models";
  }

  // Identities

  identity key-algorithm {
    description
      "Base identity from which all key-algorithms are derived.";
  }

  identity rsa1024 {
    base key-algorithm;
    description
      "The RSA algorithm using a 1024-bit key.";
    reference
      "RFC3447: Public-Key Cryptography Standards (PKCS) #1:
                RSA Cryptography Specifications Version 2.1.";
  }

  identity rsa2048 {
    base key-algorithm;
    description
      "The RSA algorithm using a 2048-bit key.";
    reference
      "RFC3447: Public-Key Cryptography Standards (PKCS) #1:
                RSA Cryptography Specifications Version 2.1.";
  }

  identity rsa3072 {
    base key-algorithm;
    description
      "The RSA algorithm using a 3072-bit key.";
    reference
      "RFC3447: Public-Key Cryptography Standards (PKCS) #1:
                RSA Cryptography Specifications Version 2.1.";
  }

  identity rsa4096 {
    base key-algorithm;
    description
      "The RSA algorithm using a 4096-bit key.";
    reference
      "RFC3447: Public-Key Cryptography Standards (PKCS) #1:
                RSA Cryptography Specifications Version 2.1.";
  }

  identity rsa7680 {
    base key-algorithm;
    description
      "The RSA algorithm using a 7680-bit key.";
    reference
      "RFC3447: Public-Key Cryptography Standards (PKCS) #1:
                RSA Cryptography Specifications Version 2.1.";
  }

  identity rsa15360 {
    base key-algorithm;
    description
      "The RSA algorithm using a 15360-bit key.";
    reference
      "RFC3447: Public-Key Cryptography Standards (PKCS) #1:
                RSA Cryptography Specifications Version 2.1.";
  }

  identity secp192r1 {
    base key-algorithm;
    description
      "The secp192r1 algorithm.";
    reference
      "RFC5480: 
         Elliptic Curve Cryptography Subject Public Key Information.";
  }

  identity secp256r1 {
    base key-algorithm;
    description
      "The secp256r1 algorithm.";
    reference
      "RFC5480: 
         Elliptic Curve Cryptography Subject Public Key Information.";
  }

  identity secp384r1 {
    base key-algorithm;
    description
      "The secp384r1 algorithm.";
    reference
      "RFC5480: 
         Elliptic Curve Cryptography Subject Public Key Information.";
  }

  identity secp521r1 {
    base key-algorithm;
    description
      "The secp521r1 algorithm.";
    reference
      "RFC5480: 
         Elliptic Curve Cryptography Subject Public Key Information.";
  }

  // data model

  container keystore {
    nacm:default-deny-write;
    description
      "The keystore contains both active material (e.g., private keys
       and passwords) and passive material (e.g., trust anchors).

       The active material can be used to support either a server (e.g.,
       a TLS/SSH server's private) or a client (a private key used for
       TLS/SSH client-certificate based authentication, or a password
       used for SSH/HTTP-client authentication).

       The passive material can be used to support either a server 
       (e.g., client certificates to trust) or clients (e.g., server
       certificates to trust).";

    container keys {
      description
        "A list of keys maintained by the keystore.";
      list key {
        key name;
        description
          "A key maintained by the keystore.";
        leaf name {
          type string;
          description
            "An arbitrary name for the key.";
        }
        leaf algorithm-identifier {
          type identityref {
            base "key-algorithm";
          }
          mandatory true;
          description
            "Identifies which algorithm is to be used to generate the
             key."; 
             // no 'params' like in RFC 5912? - none are set for
             // algs we care about, but what about the future?
        }
        leaf private-key {
          nacm:default-deny-all;
          type union {
            type binary;
            type enumeration {
              enum "INACCESSIBLE" {
                description
                 "The private key is inaccessible due to being protected
                  by a cryptographic hardware module (e.g., a TPM).";
              }
            }
          }
          mandatory true;
          description
            "A binary string that contains the value of the private
             key. The interpretation of the content is defined in the
             registration of the key algorithm.  For example, a DSA key
             is an INTEGER, an RSA key is represented as RSAPrivateKey
             as defined in [RFC3447], and an Elliptic Curve Cryptography
             (ECC) key is represented as ECPrivateKey as defined in
             [RFC5915]"; // text lifted from RFC5958
        }

        // no key usage (ref: RFC 5912, pg 101 -- too X.509 specific?)

        leaf public-key {
          type binary;
          config false;
          mandatory true;
          description
            "A binary string that contains the value of the public
             key. The interpretation of the content is defined in the
             registration of the key algorithm.  For example, a DSA key
             is an INTEGER, an RSA key is represented as RSAPublicKey
             as defined in [RFC3447], and an Elliptic Curve Cryptography
             (ECC) key is represented using the 'publicKey' described in
             [RFC5915]";
        }
        container certificates {
          description
            "Certificates associated with this private key.  More
             than one certificate per key is enabled to support, 
             for instance, a TPM-protected key that has associated
             both IDevID and LDevID certificates.";
          list certificate {
            key name;
            description
              "A certificate for this private key.";
            leaf name {
              type string;
              description
                "An arbitrary name for the certificate.  The name
                 must be a unique across all keys, not just within
                 this key.";
            }
            leaf value {
              type binary;
              description
               "An unsigned PKCS #7 SignedData structure, as specified
                by Section 9.1 in RFC 2315, containing just certificates
                (no content, signatures, or CRLs), encoded using ASN.1
                distinguished encoding rules (DER), as specified in
                ITU-T X.690.
        
                This structure contains, in order, the certificate
                itself and all intermediate certificates leading up
                to a trust anchor certificate.  The certificate MAY
                optionally include the trust anchor certificate.";
              reference
                "RFC 2315:
                   PKCS #7: Cryptographic Message Syntax Version 1.5.
                 ITU-T X.690:
                   Information technology – ASN.1 encoding rules:
                   Specification of Basic Encoding Rules (BER),
                   Canonical Encoding Rules (CER) and Distinguished
                   Encoding Rules (DER).";
            }
          }
        }
        action generate-certificate-signing-request {
          description
            "Generates a certificate signing request structure for
             the associated private key using the passed subject and
             attribute values.  The specified assertions need to be
             appropriate for the certificate's use.  For example,
             an entity certificate for a TLS server SHOULD have
             values that enable clients to satisfy RFC 6125
             processing.";
          input {
            leaf subject {
              type binary;
              mandatory true;
              description
                "The 'subject' field from the CertificationRequestInfo
                 structure as specified by RFC 2986, Section 4.1 encoded
                 using the ASN.1 distinguished encoding rules (DER), as
                 specified in ITU-T X.690.";
              reference
                "RFC 2986:
                   PKCS #10: Certification Request Syntax Specification
                   Version 1.7.
                 ITU-T X.690:
                    Information technology – ASN.1 encoding rules:
                    Specification of Basic Encoding Rules (BER), 
                    Canonical Encoding Rules (CER) and Distinguished
                    Encoding Rules (DER).";
            } 
            leaf attributes {
              type binary;
              description 
               "The 'attributes' field from the CertificationRequestInfo
                structure as specified by RFC 2986, Section 4.1 encoded
                using the ASN.1 distinguished encoding rules (DER), as
                specified in ITU-T X.690.";
              reference
                "RFC 2986:
                   PKCS #10: Certification Request Syntax Specification
                   Version 1.7.
                 ITU-T X.690:
                    Information technology – ASN.1 encoding rules:
                    Specification of Basic Encoding Rules (BER), 
                    Canonical Encoding Rules (CER) and Distinguished
                    Encoding Rules (DER).";
            }
          }
          output {
            leaf certificate-signing-request {
              type binary;
              mandatory true;
              description
                "A CertificationRequest structure as specified by RFC
                 2986, Section 4.1 encoded using the ASN.1 distinguished
                 encoding rules (DER), as specified in ITU-T X.690.";
              reference
                "RFC 2986:
                   PKCS #10: Certification Request Syntax Specification
                   Version 1.7.
                 ITU-T X.690:
                    Information technology – ASN.1 encoding rules:
                    Specification of Basic Encoding Rules (BER), 
                    Canonical Encoding Rules (CER) and Distinguished
                    Encoding Rules (DER).";

            }
          }
        }
      } // end key

      action generate-private-key {
        description
          "Requests the device to generate a private key using the
           specified key algorithm.  This action is primarily to
           support cryptographic processors that MUST generate
           the private key themselves.  The resulting key is
           considered operational state and hence initially only
           present in the <operational> datastore, as defined in
           [I-D.netmod-revised-datastores].";
        input {
          leaf name {
            type string;
            mandatory true;
            description
              "The name this private-key should have when listed
               in /keys/key.  As such, the passed value MUST NOT
               match any existing 'name' value.";
          }
          leaf algorithm {
            type identityref {
              base "key-algorithm";
            }
            mandatory true;
            description
              "The algorithm to be used when generating the key.";
          }
        }
      } // end generate-private-key
    } // end keys

    list trusted-certificates {
      key name;
      description
        "A list of trusted certificates.  These certificates
         can be used by a server to authenticate clients, or by
         clients to authenticate servers.  The certificates may
         be endpoint specific or for certificate authorities,
         to authenticate many clients at once.  Each list of
         certificates SHOULD be specific to a purpose, as the
         list as a whole may be referenced by other modules.
         For instance, a NETCONF server model might point to
         a list of certificates to use when authenticating
         client certificates.";
      leaf name {
        type string;
        description
          "An arbitrary name for this list of trusted certificates.";
      }
      leaf description {
        type string;
        description
          "An arbitrary description for this list of trusted
           certificates.";
      }
      list trusted-certificate {
        key name;
        description
          "A trusted certificate for a specific use.  Note, this
           'certificate' is a list in order to encode any 
           associated intermediate certificates.";
        leaf name {
          type string;
          description
            "An arbitrary name for this trusted certificate. Must
             be unique across all lists of trusted certificates
             (not just this list) so that a leafref to it from
             another module can resolve to unique values.";
        }
        leaf certificate {  // rename to 'data'?
          type binary;
          description
            "An X.509 v3 certificate structure as specified by RFC
             5280, Section 4 encoded using the ASN.1 distinguished
             encoding rules (DER), as specified in ITU-T X.690.";
          reference
            "RFC 5280:
               Internet X.509 Public Key Infrastructure Certificate
               and Certificate Revocation List (CRL) Profile.
             ITU-T X.690:
                Information technology – ASN.1 encoding rules:
                Specification of Basic Encoding Rules (BER), 
                Canonical Encoding Rules (CER) and Distinguished
                Encoding Rules (DER).";
        }
      }
    }

    list trusted-host-keys {
      key name;
      description
        "A list of trusted host-keys.  These host-keys can be used
         by clients to authenticate SSH servers.  The host-keys are
         endpoint specific.  Each list of host-keys SHOULD be 
         specific to a purpose, as the list as a whole may be
         referenced by other modules.  For instance, a NETCONF
         client model might point to a list of host-keys to use
         when authenticating servers host-keys.";
      leaf name {
        type string;
        description
          "An arbitrary name for this list of trusted SSH host keys.";
      }
      leaf description {
        type string;
        description
          "An arbitrary description for this list of trusted SSH host
           keys.";
      }
      list trusted-host-key {
        key name;
        description
          "A trusted host key.";
        leaf name {
          type string;
          description
            "An arbitrary name for this trusted host-key. Must be
             unique across all lists of trusted host-keys (not just
             this list) so that a leafref to it from another module
             can resolve to unique values.

             Note that, for when the SSH client is able to listen 
             for call-home connections as well, there is no reference
             identifier (e.g., hostname, IP address, etc.) that it
             can use to uniquely identify the server with.  The
             call-home draft recommends SSH servers use X.509v3
             certificates (RFC6187) when calling home.";
        }
        leaf host-key {  // rename to 'data'?
          type binary;
          mandatory true;
          description  // is this the correct type?
            "An OneAsymmetricKey 'publicKey' structure as specified
             by RFC 5958, Section 2 encoded using the ASN.1 
             distinguished encoding rules (DER), as specified
             in ITU-T X.690.";
          reference
            "RFC 5958:
                Asymmetric Key Packages
             ITU-T X.690:
                Information technology – ASN.1 encoding rules:
                Specification of Basic Encoding Rules (BER), 
                Canonical Encoding Rules (CER) and Distinguished
                Encoding Rules (DER).";
        }
      }
    }
  }

  notification certificate-expiration {
    description
      "A notification indicating that a configured certificate is 
       either about to expire or has already expired.  When to send
       notifications is an implementation specific decision, but
       it is RECOMMENDED that a notification be sent once a month
       for 3 months, then once a week for four weeks, and then once
       a day thereafter.";
    leaf certificate {
      type instance-identifier;
      mandatory true;
      description
        "Identifies which certificate is expiring or is expired.";
    }
    leaf expiration-date {
      type yang:date-and-time;
      mandatory true;
      description
        "Identifies the expiration date on the certificate.";
    }
  }

}


<CODE ENDS>
]]></artwork>
            </figure>
          </t>
        </section>
      </section>

      <section title="Design Considerations">
        <t>This document uses PKCS #10 <xref target="RFC2986"/> for the
        "generate-certificate-signing-request" action.  The use of Certificate
        Request Message Format (CRMF) <xref target="RFC4211"/> was considered,
        but is was unclear if there was market demand for it, and so support
        for CRMF has been left out of this specification.  If it is desired 
        to support CRMF in the future, placing a "choice" statement in both
        the input and output statements, along with an "if-feature" statement
        on the CRMF option, would enable a backwards compatible solution.</t>

        <t>This document puts a limit of the number of elliptical curves
        supported by default.  This was done to match industry trends in IETF best
        practice (e.g., matching work being done in TLS 1.3).  If additional
        algorithms are needed, they MAY be augmented in by another module,
        or added directly in a future version of this document.</t>

        <t>For the trusted-certificates list, Trust Anchor Format <xref target="RFC5914"/>
        was evaluated and deemed inappropriate due to this document's need to also support
        pinning.  That is, pinning a client-certificate to support NETCONF over TLS
        client authentication.</t>
 
      </section>

      <section title="Security Considerations">

        <t>The YANG module defined in this document is designed to be accessed via YANG
        based management protocols, such as NETCONF <xref target="RFC6241"/> and
        RESTCONF <xref target="RFC8040"/>.  Both of these protocols have mandatory-to-implement
        secure transport layers (e.g., SSH, TLS) with mutual authentication.</t>
 
        <t>The NETCONF access control model (NACM) <xref target="RFC6536"/> provides the means
        to restrict access for particular users to a pre-configured subset of all available
        protocol operations and content.</t>
 
        <t>There are a number of data nodes defined in this YANG module that are 
        writable/creatable/deletable (i.e., config true, which is the default). These data
        nodes may be considered sensitive or vulnerable in some network environments. Write
        operations (e.g., edit-config) to these data nodes without proper protection can
        have a negative effect on network operations. These are the subtrees and data nodes
        and their sensitivity/vulnerability:
          <list style="hanging" hangIndent="6">
            <t hangText="   /:">The entire data tree defined by this module is sensitive to
              write operations.  For instance, the addition or removal of keys, certificates,
              trusted anchors, etc., can dramatically alter the implemented security policy.
              This being the case, the top-level node in this module is marked with the NACM
              value 'default-deny-write'.</t>
            <t hangText="   /keystore/keys/key/private-key:">When writing this node,
              implementations MUST ensure that the strength of the key being configured
              is not greater than the strength of the underlying secure transport 
              connection over which it is communicated.  Implementations SHOULD fail the 
              write-request if ever the strength of the private key is greater then
              the strength of the underlying transport, and alert the client that the
              strength of the key may have been compromised.  Additionally, when deleting
              this node, implementations SHOULD automatically (without explicit request)
              zeroize these keys in the most secure manner available, so as to prevent
              the remnants of their persisted storage locations from being analyzed in
              any meaningful way.</t>
          </list>
        </t>
 
        <t>Some of the readable data nodes in this YANG module may be considered sensitive
        or vulnerable in some network environments. It is thus important to control read 
        access (e.g., via get, get-config, or notification) to these data nodes. These are
        the subtrees and data nodes and their sensitivity/vulnerability:
          <list style="hanging" hangIndent="6">
            <t hangText="   /keystore/keys/key/private-key:">This node is additionally
              sensitive to read operations such that, in normal use cases, it should never
              be returned to a client.  The best reason for returning this node is to support
              backup/restore type workflows.  This being the case, this node is marked
              with the NACM value 'default-deny-all'.</t>
          </list>
        </t>
 
        <t>Some of the RPC operations in this YANG module may be considered sensitive or
        vulnerable in some network environments. It is thus important to control access
        to these operations. These are the operations and their sensitivity/vulnerability:
          <list style="hanging" hangIndent="6">
            <t hangText="   generate-certificate-signing-request:">For this RPC operation,
              it is RECOMMENDED that implementations assert channel binding <xref target="RFC5056"/>,
              so as to ensure that the application layer that sent the request is the same
              as the device authenticated when the secure transport layer was established.</t>
          </list>
        </t>

      </section>

      <section title="IANA Considerations">
        <section title="The IETF XML Registry">
          <t>This document registers one URI in the IETF XML 
          registry <xref target="RFC3688"/>.  Following the format in 
          <xref target="RFC3688"/>, the following registration is
          requested:</t>
          <t>
            <figure>
                <artwork><![CDATA[
   URI: urn:ietf:params:xml:ns:yang:ietf-keystore
   Registrant Contact: The NETCONF WG of the IETF.
   XML: N/A, the requested URI is an XML namespace.
]]></artwork>
            </figure>
          </t>
        </section>
        <section title="The YANG Module Names Registry">
          <t>This document registers one YANG module in the
          YANG Module Names registry <xref target="RFC6020"/>.
          Following the format in <xref target="RFC6020"/>, the
          the following registration is requested:</t>
          <t>
            <figure>
                <artwork><![CDATA[
   name:         ietf-keystore
   namespace:    urn:ietf:params:xml:ns:yang:ietf-keystore
   prefix:       kc
   reference:    RFC VVVV

]]></artwork>
            </figure>
          </t>
        </section>
      </section>


      <section title="Acknowledgements">
        <t>The authors would like to thank for following for
        lively discussions on list and in the halls (ordered
        by last name): Andy Bierman, Martin Bjorklund, Benoit Claise,
        Mehmet Ersue, Balázs Kovács, David Lamparter, Alan Luchuk, Ladislav Lhotka,
        Radek Krejci, Tom Petch, Juergen Schoenwaelder; Phil Shafer, 
        Sean Turner, and Bert Wijnen.</t>
     </section>

    </middle>

    <back>
      <references title="Normative References">
        <?rfc include="reference.RFC.2119.xml"?>
        <?rfc include="reference.RFC.2986.xml"?>
        <?rfc include="reference.RFC.5280.xml"?>
        <?rfc include="reference.RFC.5958.xml"?>
        <?rfc include="reference.RFC.6020.xml"?>
        <?rfc include="reference.RFC.6536.xml"?>
      </references>
      <references title="Informative References">
        <?rfc include="reference.RFC.3688.xml"?>
        <?rfc include="reference.RFC.4211.xml"?>
        <?rfc include="reference.RFC.5056.xml"?>
        <?rfc include="reference.RFC.5914.xml"?>
        <?rfc include="reference.RFC.6241.xml"?>
        <?rfc include="reference.RFC.8040.xml"?>
        <reference anchor="Std-802.1AR-2009" target="http://standards.ieee.org/findstds/standard/802.1AR-2009.html">
            <front>
                <title>IEEE Standard for Local and metropolitan area networks - Secure Device Identity</title>
                <author fullname="WG802.1 - Higher Layer LAN Protocols Working Group">
                    <organization>IEEE SA-Standards Board</organization>
                </author>
                <date month="December" year="2009"/>
            </front>
        </reference>
      </references>

      <section title="Change Log">
        <section title="server-model-09 to 00">
          <t>
            <list style="symbols">
              <t>This draft was split out from draft-ietf-netconf-server-model-09.</t>
              <t>Removed key-usage parameter from generate-private-key action.</t>
              <t>Now /private-keys/private-key/certificates/certificate/name
              must be globally unique (unique across all private keys).</t>
              <t>Added top-level 'trusted-ssh-host-keys' and 'user-auth-credentials'
              to support SSH client modules.</t>
            </list>
          </t>
        </section>
        <section title="keychain-00 to keystore-00">
          <t>
            <list style="symbols">
              <t>Renamed module from "keychain" to "keystore" (Issue #3)</t>
            </list>
          </t>
        </section>
        <section title="00 to 01">
          <t>
            <list style="symbols">
              <t>Replaced the 'certificate-chain' structures with PKCS#7 structures.
              (Issue #1)</t>
              <t>Added 'private-key' as a configurable data node, and removed the
              'generate-private-key' and 'load-private-key' actions.  (Issue #2)</t>
              <t>Moved 'user-auth-credentials' to the ietf-ssh-client module.
              (Issues #4 and #5)</t>
            </list>
          </t>
        </section>
        <section title="01 to 02">
          <t>
            <list style="symbols">
              <t>Added back 'generate-private-key' action.</t>
              <t>Removed 'RESTRICTED' enum from the 'private-key' leaf type.</t>
              <t>Fixed up a few description statements.</t>
            </list>
          </t>
        </section>
      </section>
    </back>
</rfc>

