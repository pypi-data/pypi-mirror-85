# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['datafunc']

package_data = \
{'': ['*']}

install_requires = \
['dotty-dict', 'mo-dots', 'traversy>=0.1.2']

setup_kwargs = {
    'name': 'datafunc',
    'version': '0.0.4',
    'description': 'Python functions for various dict, list, and other data structures.',
    'long_description': '# datafunc\n\nPython package of various functions for dict, list, and other data structures.\n\n[![Actively Maintained](https://img.shields.io/badge/Maintained%3F-yes-green.svg)](https://gitHub.com/TensorTom/datafunc/graphs/commit-activity)\n[![MIT License](https://img.shields.io/pypi/l/ansicolortags.svg)](https://pypi.python.org/pypi/datafunc/)\n[![PyPI pyversions](https://img.shields.io/pypi/pyversions/ansicolortags.svg)](https://pypi.python.org/pypi/datafunc/)\n\n### Changelog\n- **11/17/2020 - 0.0.4** : Add missing type annotation. Generate docs.\n- **11/17/2020 - 0.0.3** : Added `duplicate()` and `add_sibling()` methods. Added some missing type declarations.\n- **11/15/2020 - 0.0.2** : Type annotations & minor refactors.\n- **11/15/2020 - 0.0.1** : Initial methods.\n\n## Reference\n\n#### flatten\n\n```python\nflatten(var: object) -> Data\n```\n\nTraverse a dict-like object and return a new one with all\nthe same values but only one layer deep.\n\n**Arguments**:\n\n- `var`: Dict-like variable to flatten.\n\n**Returns**:\n\nA mo-dots dict-like Data object.\n\n<a name="datafunc.iterable"></a>\n#### iterable\n\n```python\niterable(var: Any) -> Boolean\n```\n\nDetermine whether or not the input variable is iterable.\n\n**Arguments**:\n\n- `var`: Any\n\n**Returns**:\n\nBoolean\n\n<a name="datafunc.listlike"></a>\n#### listlike\n\n```python\nlistlike(var: Any) -> Boolean\n```\n\nDetermine if the input variable is list-like\n(Not a str, not dict-like, but is iterable)\n\n**Arguments**:\n\n- `var`: Any\n\n**Returns**:\n\nBoolean\n\n<a name="datafunc.mo_dotian"></a>\n#### mo\\_dotian\n\n```python\nmo_dotian(var: Any) -> Boolean\n```\n\nDetermine whether or not the input var is a mo-dots type.\n\n**Arguments**:\n\n- `var`: Any\n\n**Returns**:\n\nBoolean\n\n<a name="datafunc.apply_if"></a>\n#### apply\\_if\n\n```python\napply_if(func_to_apply: Callable, var: Any, condition: Callable, else_func: Callable = do_nothing) -> Any\n```\n\nApply func_to_apply() to var if condiction() else apply else_func()\n\n**Arguments**:\n\n- `func_to_apply`: Callable to pass var to if condition(var) return true\n- `var`: Variable to test against condition and return through func_to_apply() or else_func()\n- `condition`: Callable to test var against. Should return a Boolean.\n- `else_func`: Callable to return var through if condition(var) returns False.\n\n**Returns**:\n\nfunc_to_apply(var) if condition(var) returns True, otherwise else_func(var)\n\n<a name="datafunc.dictlike"></a>\n#### dictlike\n\n```python\ndictlike(var: Any) -> Boolean\n```\n\nDetermine whether or not var is dict-like (Can\ncontain dict-like items).\n\n**Arguments**:\n\n- `var`: Any variable to check\n\n**Returns**:\n\nBoolean\n\n<a name="datafunc.nestable"></a>\n#### nestable\n\n```python\nnestable(var: Any) -> Boolean\n```\n\nWill return True if input var is either list-like or\ndict-like.\n\n**Arguments**:\n\n- `var`: Any input variable.\n\n**Returns**:\n\nBoolean\n\n<a name="datafunc.jsonify_nestable_vals"></a>\n#### jsonify\\_nestable\\_vals\n\n```python\njsonify_nestable_vals(obj: object) -> Data\n```\n\nConvert any nestable (Dict-like or list-like) to a dict-like mo-dots\nData object of obj\'s values as JSON strings.\n\n**Arguments**:\n\n- `obj`: Any nestable variable.\n\n**Returns**:\n\nA dict-like mo-dots Data object of obj\'s values as JSON strings.\n\n<a name="datafunc.compare"></a>\n#### compare\n\n```python\ncompare(d1: object, d2: object) -> Data\n```\n\nCompare dict-like variable d1 to dict-like variable d2\nand return a dict-like mo-dots Data object of what\'s\nbeen added, removed, modified, or remained equal in d2\n\n**Arguments**:\n\n- `d1`: Dict-like variable as the base variable.\n- `d2`: Dict-like variable to compare/contrast to d1\n\n**Returns**:\n\nDict-like mo-dots Data object of differences between d1 and d2.\n\n<a name="datafunc.function_of"></a>\n#### function\\_of\n\n```python\nfunction_of(func: Callable, func_names: Tuple) -> Boolean\n```\n\nDetermine whether or not a function\'s (func) name exists in tuple of strings\n(func_names).\n\n**Arguments**:\n\n- `func`: The callable function to test.\n- `func_names`: Tuple of function names as strings ("func1", "func2", "func3,)\n\n**Returns**:\n\nBoolean True (func is of func_names) or False (func is not of func_names)\n\n<a name="datafunc.basevals"></a>\n#### basevals\n\n```python\nbasevals(var: object, *attrs) -> Any\n```\n\nThis method receives a dict and list of attributes\nto return the innermost value of the given dict-like\nvar. This function seems stupid and I don\'t recall\nwhat it was for.\n\n<a name="datafunc.vivify"></a>\n#### vivify\n\n```python\nvivify(var: object, *attrs: str)\n```\n\nAdds the last attr variable passed to the dict-like "var"\nin the hierarchy mentioned via the prior *attrs\nFor ex:\nvivify(animals, "cat", "leg","fingers", 4) is equivalent to animals["cat"]["leg"]["fingers"]=4\nThis method creates necessary objects until it reaches the final depth\nThis behaviour is also known as autovivification and plenty of implementation are around\nThis implementation addresses the corner case of replacing existing primitives\nhttps://gist.github.com/hrldcpr/2012250#gistcomment-1779319\n\n<a name="datafunc.duplicate"></a>\n#### duplicate\n\n```python\nduplicate(data: object) -> object\n```\n\nConvenience method for copy.deepcopy()\n\n**Arguments**:\n\n- `data`: Any dict, mo-dots, or dotty object.\n\n**Returns**:\n\nA deep copy of the data.\n\n<a name="datafunc.add_sibling"></a>\n#### add\\_sibling\n\n```python\nadd_sibling(data: object, node_path: List, new_key: str, new_data: Any, _i: int = 0)\n```\n\nTraversal-safe method to add a siblings data node.\n\n**Arguments**:\n\n- `data`: The data object you\'re traversing.\n- `node_path`: List of path segments pointing to the node you\'re creating a\nsibling of. Same as node_path of traverse()\n- `new_key`: The sibling key to create.\n- `new_data`: The new data to be stored at the key.\n- `_i`: Depth of node_path iterator.',
    'author': 'Tom A.',
    'author_email': '14287229+TensorTom@users.noreply.github.com',
    'maintainer': None,
    'maintainer_email': None,
    'url': 'https://github.com/tensortom/datafunc',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.6,<4.0',
}


setup(**setup_kwargs)
